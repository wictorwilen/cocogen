# Content connector tutorial (TypeSpec → .NET + JSON)

This is a beginner-friendly, from-scratch tutorial for a **content** connector using TypeSpec (`.tsp`) and cocogen. You’ll iterate on the schema, generate a .NET project with JSON input, customize mapping for `@coco.noSource` and `@coco.content`, then provision and ingest.

## 0) What you need
- **Node.js 22+**
- **.NET SDK 10**
- A Microsoft Entra app registration with Microsoft Graph permissions (see the generated project README)

---

## 1) Start with a minimal TypeSpec
You can either create the file manually or scaffold it with `init` (recommended for IntelliSense).

### Option A: scaffold with `init`
```bash
npx @wictorwilen/cocogen@latest init --out ./schema.tsp --kind content
```

This creates `schema.tsp`, `tspconfig.yaml`, and a local `package.json` so TypeSpec tooling can resolve `using coco;`. Then:

```bash
npm install
```

### Option B: create by hand
Create `schema.tsp`:

```tsp
using coco;

@coco.connection({
  name: "Incident connector",
  connectionId: "incidentconnector",
  connectionDescription: "Content connector generated by cocogen"
})
@coco.item
model Incident {
  @coco.id
  id: string;

  title: string;
}
```

This gives you a basic external item with an ID and a title.

### Validate early
Use `validate` to catch schema issues before generating:

```bash
npx @wictorwilen/cocogen@latest validate --tsp ./schema.tsp
```

---

## 2) Add fields
Now add more properties that will map to Graph schema fields:

```tsp
using coco;

@coco.connection({
  name: "Incident connector",
  connectionId: "incidentconnector",
  connectionDescription: "Content connector generated by cocogen"
})
@coco.item
model Incident {
  @coco.id
  id: string;

  title: string;
  summary: string;
  url: string;
  tags: string[];
}
```

---

## 3) Add search and label decorators
Make your fields searchable and label a few semantic fields:

```tsp
using coco;

@coco.connection({
  name: "Incident connector",
  connectionId: "incidentconnector",
  connectionDescription: "Content connector generated by cocogen"
})
@coco.item
model Incident {
  @coco.id
  id: string;

  @coco.label("title")
  @coco.search({ searchable: true, retrievable: true })
  title: string;

  @coco.search({ retrievable: true })
  summary: string;

  @coco.label("url")
  @coco.search({ retrievable: true })
  url: string;

  @coco.search({ retrievable: true })
  tags: string[];
}
```

Reference docs:
- [Semantic labels and property attributes](https://learn.microsoft.com/en-us/graph/connecting-external-content-manage-schema#schema-attributes)
- [Schema resource type](https://learn.microsoft.com/en-us/graph/api/resources/externalconnectors-schema)

---

## 4) Add JSON source mappings (JSONPath)
When using JSON input, `@coco.source("...")` is interpreted as JSONPath.

```tsp
using coco;

@coco.connection({
  name: "Incident connector",
  connectionId: "incidentconnector",
  connectionDescription: "Content connector generated by cocogen"
})
@coco.item
model Incident {
  @coco.id
  @coco.source("id")
  id: string;

  @coco.label("title")
  @coco.search({ searchable: true, retrievable: true })
  @coco.source("title")
  title: string;

  @coco.search({ retrievable: true })
  @coco.source("summary")
  summary: string;

  @coco.label("url")
  @coco.search({ retrievable: true })
  @coco.source("url")
  url: string;

  @coco.search({ retrievable: true })
  @coco.source("tags[*]")
  tags: string[];
}
```

---

## 5) Add `@coco.noSource` and `@coco.content`
`@coco.noSource` tells cocogen the field is computed (no input mapping). `@coco.content` marks the full-text content field.

```tsp
using coco;

@coco.connection({
  name: "Incident connector",
  connectionId: "incidentconnector",
  connectionDescription: "Content connector generated by cocogen"
})
@coco.item
model Incident {
  @coco.id
  @coco.source("id")
  id: string;

  @coco.label("title")
  @coco.search({ searchable: true, retrievable: true })
  @coco.source("title")
  title: string;

  @coco.search({ retrievable: true })
  @coco.source("summary")
  summary: string;

  @coco.label("url")
  @coco.search({ retrievable: true })
  @coco.source("url")
  url: string;

  @coco.search({ retrievable: true })
  @coco.source("tags[*]")
  tags: string[];

  @coco.noSource
  sourceSystem: string;

  @coco.content({ type: "text" })
  content: string;
}
```

- `sourceSystem` is a computed field (e.g., “IncidentService”).
- `content` should be a **Markdown** string built from a subset of attributes.

---

## 6) Generate a .NET + JSON project
Run:

```bash
npx @wictorwilen/cocogen@latest generate \
  --tsp ./schema.tsp \
  --lang dotnet \
  --data-format json \
  --out ./incident-connector
```

### Input formats (at generation time)
- **csv** (default): CSV input with headers.
- **json**: JSON input with JSONPath mapping.
- **yaml**: YAML input with JSONPath mapping.
- **rest**: REST input with JSONPath mapping.
- **custom**: emits a stub datasource to replace.

### Output
The generated project includes:
- `data.json` (sample input)
- `Datasource/JsonItemSource.cs` (JSON reader)
- `PropertyTransformBase.cs` (generated mapping)
- `PropertyTransform.cs` (safe place for your custom logic)

---

## 7) Quick tour of the .NET scaffold
In `incident-connector/`:
- `Program.cs` — CLI: provision, ingest, delete
- `Datasource/JsonItemSource.cs` — reads JSON rows
- `PropertyTransformBase.cs` — generated mapping
- `PropertyTransform.cs` — **your customization hook**
- `appsettings.json` — config defaults

---

## 8) Add custom logic for `@coco.noSource` + `@coco.content`
Edit `PropertyTransform.cs` (safe file):

```csharp
// Customize row-to-model property transforms.
namespace IncidentConnector;

public sealed class PropertyTransform : PropertyTransformBase
{
    protected override string TransformSourceSystem(object row)
    {
      return "IncidentService";
    }

    protected override string TransformContent(object row)
    {
        var title = RowParser.ParseString(row, "$.title");
        var summary = RowParser.ParseString(row, "$.summary");
        var url = RowParser.ParseString(row, "$.url");
        var tags = RowParser.ParseStringCollection(row, "$.tags[*]");

        return BuildMarkdown(title, summary, url, tags);
    }

    private static string BuildMarkdown(string title, string summary, string url, List<string> tags)
    {
        var tagLine = tags.Count > 0 ? string.Join(", ", tags) : "(none)";
        return $"""
# {title}

{summary}

**Source:** {url}

**Tags:** {tagLine}
""".Trim();
    }
}
```

This builds a Markdown content value from a subset of fields.

---

## 9) Provision the connection
From the project folder:

```bash
dotnet run -- provision
```

---

## 10) Ingest data (JSON)
Use the sample `data.json` or your own input:

```bash
dotnet run -- ingest --input ./data.json
```

Helpful flags:
- `--dry-run` (build payloads without sending to Graph)
- `--verbose` (print payloads)
- `--limit 10` (limit items)

---

## 11) Next steps
- Add or rename properties in `schema.tsp`.
- Re-run generation with `cocogen update --out ./incident-connector`.
- Extend ingestion by swapping `JsonItemSource` with your own datasource.
