# End-user guide

This guide walks you through writing TypeSpec (`.tsp`) files, running `cocogen`, and working safely with the generated projects.

For agents helping others craft schemas, see docs/schema-assistant.md.

## Prerequisites
- Node.js 22+ (the generator targets Node 22 LTS)
- A TypeSpec schema file (`.tsp`)
- For generated projects: Azure app registration + Microsoft Graph permissions (see each generated project README)

## 1) Create your TypeSpec schema

### Generate a starter schema (prompt)
```bash
npx @wictorwilen/cocogen@latest init --prompt
```

Non-interactive:
```bash
npx @wictorwilen/cocogen@latest init --out ./schema.tsp --kind content
```

`init` also creates `package.json` and `tspconfig.yaml` alongside the schema if they are missing.

### Minimal content connector
```tsp
using coco;

@coco.connection({
  name: "Ticket connector",
  connectionId: "ticketconnector",
  connectionDescription: "Ticket connector generated by cocogen"
})
@coco.item()
model Ticket {
  @coco.id
  ticketId: string;

  @coco.label("title")
  @coco.search({ searchable: true, retrievable: true })
  title: string;

  @coco.content({ type: "text" })
  body: string;
}
```

### Minimal people connector (preview)
```tsp
using coco;

@coco.connection({
  contentCategory: "people",
  name: "People connector",
  connectionId: "peopleconnector",
  connectionDescription: "People connector generated by cocogen"
})
@coco.item()
model PersonProfile {
  @coco.id
  @coco.label("personAccount")
  @coco.source("upn", "userPrincipalName")
  userPrincipalName: string;

  @coco.label("personName")
  @coco.source("displayName", "displayName")
  displayName: string;
}
```

### Required rules
- Exactly one model must be marked with `@coco.item()`.
- Exactly one property must be marked with `@coco.id` (and it must be `string`).
- The item model must define `@coco.connection` with `name` and `connectionId` (description recommended).
- The model must be flat (no nested objects or models).
- Property names in Graph must be alphanumeric and ≤ 32 characters. Use `@coco.name("...")` if needed.
- People-labeled properties must define at least one `@coco.source("column", "entity.path")` mapping.
- People label values must be JSON-encoded strings (single labels) or arrays of JSON strings (collection labels).

### Common decorators you will use
- `@coco.label("...")` — marks Graph property labels (including people labels)
- `@coco.search({ ... })` — search flags for Graph schema
- `@coco.content({ type: "text" })` — full-text content field (not allowed for people connectors)
- `@coco.source("csvHeader")` — map a property to a CSV header
- `@coco.source("csvHeader", "entity.path")` — people entity mapping from CSV to entity path
- `@coco.noSource` — mark a property as having no CSV source mapping
- `@coco.connection({ contentCategory?, name, connectionId, connectionDescription? })`
- `@coco.profileSource({ webUrl, displayName, priority? })` (people connectors)
- `@doc("...")` — add inline documentation to generated model files
- `@example(...)` — seed the sample CSV row
- `@minLength`, `@maxLength`, `@minValue`, `@maxValue`, `@pattern`, `@format` — runtime validation in transform methods
- `#deprecated "message"` — omit the property from generated schema/model/mapping

Note: do NOT add `using TypeSpec;` and do NOT use `@TypeSpec.*` in schemas.

For the complete spec and validation rules, see docs/typespec.md.

### Fixing TypeSpec editor squiggles (VS Code)
Starter schemas created by `init` include `tspconfig.yaml` and a local `package.json`. To let the TypeSpec language server resolve `using coco;`:
- TypeScript projects: run `npm install` (installs `@wictorwilen/cocogen`).
- .NET projects: run `npm install` in the project folder (installs `@wictorwilen/cocogen`).

## 2) Validate the schema
```bash
npx @wictorwilen/cocogen@latest validate --tsp ./schema.tsp
```

If you use Graph beta features (for example `contentCategory: "people"`), pass:
```bash
npx @wictorwilen/cocogen@latest validate --tsp ./schema.tsp --use-preview-features
```

## 3) Generate a project

### TypeScript
```bash
npx @wictorwilen/cocogen@latest generate --tsp ./schema.tsp --out ./my-connector
```
To generate a JSON or YAML input project:
```bash
npx @wictorwilen/cocogen@latest generate --tsp ./schema.tsp --out ./my-connector --data-format json
```
To generate a custom input project (no built-in datasource):
```bash
npx @wictorwilen/cocogen@latest generate --tsp ./schema.tsp --out ./my-connector --data-format custom
```
This emits a stub datasource that throws until you replace it with your own backend implementation.
Input format is fixed at generation time. To switch formats, re-run `generate` into a new folder.

### .NET
```bash
npx @wictorwilen/cocogen@latest generate --tsp ./schema.tsp --out ./my-connector --lang dotnet
```

### REST (.http files)
```bash
npx @wictorwilen/cocogen@latest generate --tsp ./schema.tsp --out ./my-connector --lang rest
```
This output creates `.http` files you can run with the VS Code REST client (or similar tools) to create the connection, patch the schema, optionally configure profile sources (people connectors), and ingest a sample item.

Preview-only schemas require the flag:
```bash
npx @wictorwilen/cocogen@latest generate --tsp ./schema.tsp --out ./my-connector --use-preview-features
```

## 4) Update generated code after schema changes
After `generate`, the project contains a `schema.tsp` copy and a `cocogen.json` that records the entry `.tsp` file.
Each generated project also includes `AGENTS.md` with quick instructions for updates and customization.

Regenerate TypeSpec-derived files:
```bash
npx @wictorwilen/cocogen@latest update --out ./my-connector
```

Override the TypeSpec file (also updates `cocogen.json`):
```bash
npx @wictorwilen/cocogen@latest update --out ./my-connector --tsp ../schema.tsp
```

## 5) Working with generated TypeScript projects

### Layout and what you can edit
- `src/<ConnectionName>/**` — generated files (folder name from `@coco.connection.name`, PascalCase). These are overwritten by `cocogen update`.
- `src/<ConnectionName>/propertyTransform.ts` — created once; safe for manual edits.
- `src/datasource/**` — **editable**. Customize how items are read (CSV, APIs, databases).
- `src/cli.ts` — **editable**. Controls provisioning/ingestion commands.
- `src/index.ts` — **editable**. Main entrypoint and pipeline composition.
- `.env` / `.env.example` — configuration values (client credentials, connection defaults).

### Typical flow
```bash
npm install
npm run build
node dist/cli.js provision
node dist/cli.js ingest --input ./data.csv
```

### Authentication
The generated CLI uses the following order:
1) Client secret (`TENANT_ID` + `CLIENT_ID` + `CLIENT_SECRET`)
2) Managed identity (when no client secret is configured)

For local development with client secret, set `TENANT_ID`, `CLIENT_ID`, and `CLIENT_SECRET` in `.env`. For Azure hosting, leave those unset and (optionally) set `MANAGED_IDENTITY_CLIENT_ID` for user-assigned identities.

Ingest debugging flags:
- `--dry-run` builds payloads but does not send to Graph
- `--limit <n>` limits items ingested
- `--verbose` prints item payloads
- `--input <path>` overrides the input file path

### Where to customize mapping
- Prefer editing the TypeSpec file and re-running `cocogen update`.
- Generated mapping helpers live in `src/<ConnectionName>/*` and are overwritten on update.
- People payload helpers live in `src/core/people.ts` and enforce JSON string payloads for people labels.
- Use `src/<ConnectionName>/propertyTransform.ts` for manual mapping tweaks (safe file).
- For advanced transforms, extend the ingestion pipeline in `src/index.ts` or `src/datasource/*`.

### Switching from the generated datasource (TypeScript)
1) Implement `ItemSource` in `src/datasource`.
2) Map your raw records to `Item` objects (you can reuse `fromRow` logic or create your own mapping).
3) Update `src/cli.ts` to instantiate your new source instead of the generated source.

## 6) Working with generated .NET projects

### Layout and what you can edit
- `<ConnectionName>/**` — generated files (folder name from `@coco.connection.name`, PascalCase). These are overwritten by `cocogen update`.
- `<ConnectionName>/PropertyTransform.cs` — created once; safe for manual edits.
- `Datasource/**` — **editable**. Customize how items are read (CSV, APIs, databases).
- `Program.cs` and `Program.commandline.cs` — **editable**. CLI and pipeline wiring.
- `appsettings.json` — configuration values (client credentials, connection defaults).

### Typical flow
```bash
dotnet build
dotnet run -- provision
dotnet run -- ingest --input ./data.csv
```

### Authentication
The generated CLI uses the following order:
1) Client secret (`AzureAd:TenantId` + `AzureAd:ClientId` + `AzureAd:ClientSecret`)
2) Managed identity (when no client secret is configured)

For local development with client secret, set the AzureAd settings in `appsettings.json`, environment variables, or user-secrets. For Azure hosting, leave the AzureAd settings empty and (optionally) set `AzureAd:ManagedIdentityClientId` for user-assigned identities.

Ingest debugging flags:
- `--dry-run` builds payloads but does not send to Graph
- `--limit <n>` limits items ingested
- `--verbose` prints item payloads
- `--input <path>` overrides the input file path

### Where to customize mapping
- Prefer editing the TypeSpec file and re-running `cocogen update`.
- Generated mapping helpers live in `<ConnectionName>/*` and are overwritten on update.
- Use `<ConnectionName>/PropertyTransform.cs` for manual mapping tweaks (safe file).
- For advanced transforms, extend the ingestion pipeline in `Program.cs` or `Datasource/*`.

### Switching from the generated datasource (.NET)
1) Implement `IItemSource` in `Datasource/`.
2) Map your raw records to `Item` objects (you can reuse `FromRow` logic or create your own mapping).
3) Update `Program.cs` to instantiate your new source instead of the generated source.

## 7) Common customization scenarios

### Change connection defaults
- Update `@coco.connection({ name, connectionId, connectionDescription })` in your TypeSpec.
- Re-run `cocogen update`.
- Update `.env` (TS) or `appsettings.json` (.NET) as needed.

### Change source mappings
- Update `@coco.source("header")` in the TypeSpec (CSV) or JSONPath values (JSON/YAML/custom).
- Re-run `cocogen update`.
- Update your input file to match the new paths.

### Add/modify people profile data
- Use people labels like `personName` or `personCurrentPosition`.
- Use `@coco.source("header", "entity.path")` to map CSV columns into the profile entity fields.

## 8) Azure Functions migration (Node + .NET)
See the end-to-end tutorial: [docs/azure-functions.md](azure-functions.md)
- For collection properties (`string[]`), CSV values can be separated with `;` and will be aligned by index.
- Collections split on semicolons only (`,` is reserved for CSV columns).
- For custom entity shaping, edit the overrides file (safe file):
- For custom entity shaping, edit the overrides file (safe file):
  - TS: `src/<ConnectionName>/propertyTransform.ts`
  - .NET: `<ConnectionName>/PropertyTransform.cs`

## 8) Troubleshooting

- If `cocogen` reports a beta requirement, re-run with `--use-preview-features`.
- If schema validation fails, run `cocogen validate` first to see actionable errors and hints.
- If your custom edits get overwritten, move them out of the generated schema folder or into the overrides file.

## Further reference
- Full TypeSpec format: docs/typespec.md
- Design details: docs/architecture.md
