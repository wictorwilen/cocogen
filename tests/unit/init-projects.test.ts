import { describe, expect, test } from "vitest";
import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";

import {
  initDotnetProject,
  initRestProject,
  initTsProject,
  updateDotnetProject,
  updateProject
} from "../../src/init/init.js";
import { writeTempDir, writeTempTspFile } from "../test-utils.js";

const baseSchema = `using coco;

@coco.connection({
  name: "Test connector",
  connectionId: "testconnection",
  connectionDescription: "Test connector"
})
@coco.item
model Item {
  @coco.id
  id: string;
  title: string;
}
`;

const complexSchema = `using coco;

@coco.connection({
  name: "Test connector",
  connectionId: "testconnection",
  connectionDescription: "Test connector"
})
@coco.item
model Item {
  @coco.id
  id: string;

  @coco.search({ searchable: true, retrievable: true })
  title: string;

  @coco.aliases("summary")
  description: string;

  @coco.content({ type: "text" })
  body: string;

  count: int64;
  rating: float64;
  isActive: boolean;
  createdAt: utcDateTime;
  tags: string[];
  counts: int64[];
  ratings: float64[];
  dates: utcDateTime[];
}
`;

const peopleSchema = `using coco;

@coco.connection({
  contentCategory: "people",
  name: "People connector",
  connectionId: "peopleconnector",
  connectionDescription: "People connector generated by cocogen"
})
@coco.profileSource({
  webUrl: "https://example.com",
  displayName: "Example people source"
})
@coco.item
model PersonProfile {
  @coco.id
  @coco.label("personAccount")
  @coco.source("upn", "userPrincipalName")
  account: string;

  @coco.label("personSkills")
  @coco.source("skill", "displayName")
  @coco.source("proficiency", "proficiency")
  skills: string[];
}
`;

const peopleSingleFieldSchema = `using coco;

@coco.connection({
  contentCategory: "people",
  name: "People connector",
  connectionId: "peopleconnector",
  connectionDescription: "People connector generated by cocogen"
})
@coco.profileSource({
  webUrl: "https://example.com",
  displayName: "Example people source"
})
@coco.item
model PersonProfile {
  @coco.id
  @coco.label("personAccount")
  @coco.source("upn", "userPrincipalName")
  account: string;

  @coco.label("personSkills")
  @example(#["TypeScript", "Python"])
  @coco.source("skill", "displayName")
  skills: string[];

  @example("Hello, world")
  nickname: string;

  @coco.noSource
  notes: string;
}
`;

const peopleNestedSchema = `using coco;

@coco.connection({
  contentCategory: "people",
  name: "People connector",
  connectionId: "peopleconnector",
  connectionDescription: "People connector generated by cocogen"
})
@coco.profileSource({
  webUrl: "https://example.com",
  displayName: "Example people source"
})
@coco.item
model PersonProfile {
  @coco.id
  @coco.label("personAccount")
  @coco.source("upn", "userPrincipalName")
  account: string;

  @coco.label("personCurrentPosition")
  @coco.source("job title", "detail.jobTitle")
  position: string;

  @coco.label("personSkills")
  @coco.source("skill", "detail.name")
  @coco.source("level", "detail.level")
  skills: string[];
}
`;

const sampleCsvSchema = `using coco;

@coco.connection({
  name: "Test connector",
  connectionId: "testconnection",
  connectionDescription: "Test connector"
})
@coco.item
model Item {
  @coco.id
  id: string;

  @coco.source("job title")
  jobTitle: string;

  @coco.source("company")
  company: string;

  @coco.source("email")
  email: string;

  @coco.source("phone")
  phone: string;

  @coco.source("address")
  address: string;

  @coco.source("country")
  country: string;

  @coco.source("note")
  note: string;

  @coco.source("header,with,comma")
  special: string;

  owner: coco.Principal;
}
`;

describe("project init/update", () => {
  test("initTsProject generates files and config", async () => {
    const tspPath = await writeTempTspFile(complexSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-project");
    const schemaFolder = "TestConnector";

    const result = await initTsProject({ tspPath, outDir, force: false });

    const config = await readFile(path.join(outDir, "cocogen.json"), "utf8");
    expect(config).toContain("\"lang\": \"ts\"");

    const model = await readFile(path.join(outDir, "src", schemaFolder, "model.ts"), "utf8");
    expect(model).toContain("export type Item");

    const copiedSchema = await readFile(path.join(outDir, "schema.tsp"), "utf8");
    expect(copiedSchema).toContain("@coco.item");

    expect(result.ir.item.typeName).toBe("Item");
  });

  test("initRestProject generates REST client .http files", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({
        contentCategory: "people",
        name: "People connector",
        connectionId: "peopleconnector",
        connectionDescription: "People connector generated by cocogen"
      })
      @coco.profileSource({
        webUrl: "https://example.com/people",
        displayName: "Example People Directory",
        priority: "first"
      })
      @coco.item
      model PersonProfile {
        @coco.id
        @coco.label("personAccount")
        @coco.source("upn", "upn")
        id: string;
        displayName: string;
      }
    `);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "rest-output");

    await initRestProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const createConnection = await readFile(path.join(outDir, "create-connection.http"), "utf8");
    expect(createConnection).toContain("/external/connections/");

    const patchSchema = await readFile(path.join(outDir, "patch-schema.http"), "utf8");
    expect(patchSchema).toContain("/schema");

    const ingestItem = await readFile(path.join(outDir, "ingest-item.http"), "utf8");
    expect(ingestItem).toContain("/items/");
    expect(ingestItem).toContain("\\\"upn\\\"");
    expect(ingestItem).toContain("{\\\"upn\\\"");

    const profileSource = await readFile(path.join(outDir, "profile-source.http"), "utf8");
    expect(profileSource).toContain("/admin/people/profileSources");
  });

  test("initRestProject emits principal collection objects", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @coco.item
      model Item {
        @coco.id
        id: string;

        @coco.source("owners", "upn")
        approvers: coco.Principal[];
      }
    `);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "rest-principal");

    await initRestProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const ingestItem = await readFile(path.join(outDir, "ingest-item.http"), "utf8");
    expect(ingestItem).toContain("\"approvers\": [");
    expect(ingestItem).toContain("\"@odata.type\": \"microsoft.graph.externalConnectors.principal\"");
  });

  test("initTsProject includes throttling retries", async () => {
    const tspPath = await writeTempTspFile(complexSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-throttle");

    await initTsProject({ tspPath, outDir, force: false });

    const core = await readFile(path.join(outDir, "src", "core", "connectorCore.ts"), "utf8");
    expect(core).toContain("Retry-After");
    expect(core).toContain("throttled");
    expect(core).toContain("MAX_RETRIES");
  });

  test("initTsProject provisions profile source separately", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-people-provision");

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const core = await readFile(path.join(outDir, "src", "core", "connectorCore.ts"), "utf8");
    expect(core).toContain("provisionProfileSource");
    const cli = await readFile(path.join(outDir, "src", "cli.ts"), "utf8");
    expect(cli).toContain("provisionProfileSource");
  });

  test("initTsProject skips duplicate people profile source updates", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-people-profile");

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const core = await readFile(path.join(outDir, "src", "core", "connectorCore.ts"), "utf8");
    expect(core).toContain("sources.some((source) => source.sourceId === connectionId)");
    expect(core).toContain("settings.find((setting) => !setting.name)");
    expect(core).toContain("current.includes(sourceUrl)");
    expect(core).toContain("profilePropertySettings");
    expect(core).toContain("prioritizedSourceUrls: [sourceUrl]");
  });

  test("updateProject regenerates schema from updated tsp", async () => {
    const tspPath = await writeTempTspFile(baseSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-update");
    const schemaFolder = "TestConnector";

    await initTsProject({ tspPath, outDir, force: false });

    const updatedSchema = `using coco;

  @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
  @coco.item
model Item {
  @coco.id
  id: string;
  title: string;
  status: string;
}
`;

    await writeFile(path.join(outDir, "schema.tsp"), updatedSchema, "utf8");

    await updateProject({ outDir });

    const model = await readFile(path.join(outDir, "src", schemaFolder, "model.ts"), "utf8");
    expect(model).toContain("status");
  });

  test("updateProject updates config when tspPath is overridden", async () => {
    const tspPath = await writeTempTspFile(baseSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-update-config");

    await initTsProject({ tspPath, outDir, force: false });

    const newSchemaPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; status: string; }`
    );
    await updateProject({ outDir, tspPath: newSchemaPath });

    const config = JSON.parse(await readFile(path.join(outDir, "cocogen.json"), "utf8")) as { tsp: string };
    expect(config.tsp).toContain(".tsp");
  });

  test("initDotnetProject generates Program.cs and SchemaConstants", async () => {
    const tspPath = await writeTempTspFile(complexSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-project");
    const schemaFolder = "TestConnector";

    await initDotnetProject({ tspPath, outDir, force: false });

    const program = await readFile(path.join(outDir, "Program.cs"), "utf8");
    expect(program).toContain("SchemaConstants");

    const constants = await readFile(path.join(outDir, schemaFolder, "Constants.cs"), "utf8");
    expect(constants).toContain("class SchemaConstants");
  });

  test("initDotnetProject includes throttling retries", async () => {
    const tspPath = await writeTempTspFile(complexSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-throttle");

    await initDotnetProject({ tspPath, outDir, force: false });

    const core = await readFile(path.join(outDir, "Core", "ConnectorCore.cs"), "utf8");
    expect(core).toContain("RetryAsync");
    expect(core).toContain("Retry-After");
    expect(core).toContain("throttled");
  });

  test("initDotnetProject provisions profile source separately", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-people-provision");

    await initDotnetProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const core = await readFile(path.join(outDir, "Core", "ConnectorCore.cs"), "utf8");
    expect(core).toContain("ProvisionProfileSourceAsync");
    const program = await readFile(path.join(outDir, "Program.cs"), "utf8");
    expect(program).toContain("ProvisionProfileSourceAsync");
  });

  test("initDotnetProject skips duplicate people profile source updates", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-people-profile");

    await initDotnetProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const core = await readFile(path.join(outDir, "Core", "ConnectorCore.cs"), "utf8");
    expect(core).toContain("ProfileSourceExistsAsync");
    expect(core).toContain("if (!string.IsNullOrWhiteSpace(nameValue))");
    expect(core).toContain("existing.Contains(sourceUrl");
    expect(core).toContain("profilePropertySettings");
    expect(core).toContain("prioritizedSourceUrls");
  });

  test("initDotnetProject avoids property name matching model name", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Awards Connector", connectionId: "awardsconnector", connectionDescription: "Connector for awards data" }) @coco.item model Awards { @coco.id id: string; awards: string[]; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-awards");
    const schemaFolder = "AwardsConnector";

    await initDotnetProject({ tspPath, outDir, force: false });

    const model = await readFile(path.join(outDir, schemaFolder, "Model.cs"), "utf8");
    expect(model).toContain("AwardsValue");
    expect(model).not.toContain("Awards Awards");
  });

  test("updateProject updates dotnet schema", async () => {
    const tspPath = await writeTempTspFile(baseSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-update");
    const schemaFolder = "TestConnector";

    await initDotnetProject({ tspPath, outDir, force: false });

    const updatedSchema = `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; status: string; }`;
    await writeFile(path.join(outDir, "schema.tsp"), updatedSchema, "utf8");
    await updateProject({ outDir });

    const model = await readFile(path.join(outDir, schemaFolder, "Model.cs"), "utf8");
    expect(model).toContain("Status");
  });

  test("updateDotnetProject updates config when tspPath is overridden", async () => {
    const tspPath = await writeTempTspFile(baseSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-update-config");

    await initDotnetProject({ tspPath, outDir, force: false });

    const newSchemaPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; status: string; }`
    );

    await updateDotnetProject({ outDir, tspPath: newSchemaPath });

    const config = JSON.parse(await readFile(path.join(outDir, "cocogen.json"), "utf8")) as { tsp: string };
    expect(config.tsp).toContain(".tsp");
  });

  test("initTsProject generates property transform base for people schema", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-project");
    const schemaFolder = "PeopleConnector";

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const transforms = await readFile(path.join(outDir, "src", schemaFolder, "propertyTransformBase.ts"), "utf8");
    expect(transforms).toContain("skills");
    expect(transforms).toContain("displayName");
    expect(transforms).toContain("userPrincipalName");
  });

  test("initTsProject emits people validators and serialization helpers", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-validators");
    const schemaFolder = "PeopleConnector";

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const helpers = await readFile(path.join(outDir, "src", "core", "people.ts"), "utf8");
    expect(helpers).toContain("export function serializePersonSkills");
    expect(helpers).toContain("validateSkillProficiency");

    const payload = await readFile(path.join(outDir, "src", schemaFolder, "itemPayload.ts"), "utf8");
    expect(payload).toContain("serializePersonSkills(");
  });

  test("initDotnetProject generates property transform base and preserves overrides", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-dotnet");
    const schemaFolder = "PeopleConnector";

    await initDotnetProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const defaults = await readFile(path.join(outDir, schemaFolder, "PropertyTransformBase.cs"), "utf8");
    expect(defaults).toContain("skill");

    const overrides = await readFile(path.join(outDir, schemaFolder, "PropertyTransform.cs"), "utf8");
    expect(overrides).toContain("PropertyTransform");

    const peoplePayload = await readFile(path.join(outDir, "Core", "PeoplePayload.cs"), "utf8");
    expect(peoplePayload).toContain("PeoplePayload");

    await updateProject({ outDir, usePreviewFeatures: true });
    const overridesAfter = await readFile(path.join(outDir, schemaFolder, "PropertyTransform.cs"), "utf8");
    expect(overridesAfter).toBe(overrides);
  });

  test("init projects generate single-field people collection transforms and noSource placeholders", async () => {
    const tspPath = await writeTempTspFile(peopleSingleFieldSchema);
    const outRoot = await writeTempDir();
    const outTs = path.join(outRoot, "people-single-ts");
    const outDotnet = path.join(outRoot, "people-single-dotnet");
    const schemaFolder = "PeopleConnector";

    await initTsProject({ tspPath, outDir: outTs, force: false, usePreviewFeatures: true });
    await initDotnetProject({ tspPath, outDir: outDotnet, force: false, usePreviewFeatures: true });

    const tsTransforms = await readFile(
      path.join(outTs, "src", schemaFolder, "propertyTransformBase.ts"),
      "utf8"
    );
    expect(tsTransforms).toContain(".map((value) => JSON.stringify");
    expect(tsTransforms).toContain("undefined as unknown as string");

    const dotnetTransforms = await readFile(path.join(outDotnet, schemaFolder, "PropertyTransformBase.cs"), "utf8");
    expect(dotnetTransforms).toContain("Select(value => JsonSerializer.Serialize");
    expect(dotnetTransforms).toContain("default!");

    const csv = await readFile(path.join(outTs, "data.csv"), "utf8");
    expect(csv).toContain("TypeScript;Python");
    expect(csv).toContain("\"Hello, world\"");
  });

  test("initDotnetProject emits nested person entity transforms", async () => {
    const tspPath = await writeTempTspFile(peopleNestedSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-nested-dotnet");
    const schemaFolder = "PeopleConnector";

    await initDotnetProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const transforms = await readFile(path.join(outDir, schemaFolder, "PropertyTransformBase.cs"), "utf8");
    expect(transforms).toContain("[\"detail\"] = new Dictionary");
    expect(transforms).toContain("GetValue");
  });

  test("initTsProject generates sample CSV with special headers", async () => {
    const tspPath = await writeTempTspFile(sampleCsvSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "sample-csv");

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const csv = await readFile(path.join(outDir, "data.csv"), "utf8");
    expect(csv).toContain("Software Engineer");
    expect(csv).toContain('"header,with,comma"');
    expect(csv).toContain("alice@contoso.com");
  });

  test("init projects use email samples for principal userPrincipalName headers", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @coco.item
      model Item {
        @coco.id
        id: string;

        @coco.search({ retrievable: true })
        @coco.source("owner", "userPrincipalName")
        @doc("The owner of the product.")
        productOwner: coco.Principal;

        @coco.search({ retrievable: true })
        @coco.source("marketingContacts", "userPrincipalName")
        @doc("The marketing contacts for the product.")
        marketingContacts: coco.Principal[];
      }
    `);

    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "principal-sample");

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const csv = await readFile(path.join(outDir, "data.csv"), "utf8");
    const lines = csv.trim().split("\n");
    expect(lines).toHaveLength(2);
    const headers = lines[0]?.split(",") ?? [];
    const values = lines[1]?.split(",") ?? [];
    const ownerIndex = headers.indexOf("owner");
    const contactsIndex = headers.indexOf("marketingContacts");
    expect(ownerIndex).toBeGreaterThanOrEqual(0);
    expect(contactsIndex).toBeGreaterThanOrEqual(0);
    expect(values[ownerIndex]).toContain("@contoso.com");
    expect(values[contactsIndex]).toContain("@contoso.com");
  });

  test("initDotnetProject emits Kiota principal serializer", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @coco.item
      model Item {
        @coco.id
        id: string;

        @coco.source("owner", "userPrincipalName")
        productOwner: coco.Principal;
      }
    `);

    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "principal-null-dotnet");

    await initDotnetProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const principal = await readFile(path.join(outDir, "Core", "Principal.cs"), "utf8");
    expect(principal).toContain("IParsable");
    expect(principal).toContain("WriteAdditionalData");
  });

  test("initTsProject strips null principal fields in payload", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @coco.item
      model Item {
        @coco.id
        id: string;

        @coco.source("owner", "userPrincipalName")
        productOwner: coco.Principal;

        @coco.source("marketingContacts", "userPrincipalName")
        marketingContacts: coco.Principal[];
      }
    `);

    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "principal-null-ts");

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    const payload = await readFile(path.join(outDir, "src", "TestConnector", "itemPayload.ts"), "utf8");
    expect(payload).toContain("cleanPrincipal(");
    expect(payload).toContain("cleanPrincipalCollection(");
  });

  test("init projects emit principalCollection odata type", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @coco.item
      model Item {
        @coco.id
        id: string;

        @coco.source("marketingContacts", "userPrincipalName")
        marketingContacts: coco.Principal[];
      }
    `);

    const outRoot = await writeTempDir();
    const outTs = path.join(outRoot, "principal-odata-ts");
    const outDotnet = path.join(outRoot, "principal-odata-dotnet");

    await initTsProject({ tspPath, outDir: outTs, force: false, usePreviewFeatures: true });
    await initDotnetProject({ tspPath, outDir: outDotnet, force: false, usePreviewFeatures: true });

    const tsPayload = await readFile(path.join(outTs, "src", "TestConnector", "itemPayload.ts"), "utf8");
    expect(tsPayload).toContain("marketingContacts@odata.type");
    expect(tsPayload).toContain("Collection(microsoft.graph.externalConnectors.principal)");

    const csPayload = await readFile(path.join(outDotnet, "TestConnector", "ItemPayload.cs"), "utf8");
    expect(csPayload).toContain("marketingContacts@odata.type");
    expect(csPayload).toContain("Collection(microsoft.graph.externalConnectors.principal)");
  });

  test("init projects use @example in CSV and emit validation", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @doc("Example item")
      @coco.item
      model Item {
        @coco.id
        @example("PRJ-1001")
        @pattern("^PRJ-[0-9]+$")
        id: string;

        @doc("Display title")
        @example("Alpha project")
        @minLength(2)
        title: string;

        @format("email")
        ownerEmail: string;
      }
    `);

    const outRoot = await writeTempDir();
    const outTs = path.join(outRoot, "example-ts");
    const outDotnet = path.join(outRoot, "example-dotnet");

    await initTsProject({ tspPath, outDir: outTs, force: false });
    await initDotnetProject({ tspPath, outDir: outDotnet, force: false });

    const csv = await readFile(path.join(outTs, "data.csv"), "utf8");
    expect(csv).toContain("PRJ-1001");
    expect(csv).toContain("Alpha project");

    const tsModel = await readFile(path.join(outTs, "src", "TestConnector", "model.ts"), "utf8");
    expect(tsModel).toContain("Example item");
    expect(tsModel).toContain("Display title");

    const tsTransforms = await readFile(
      path.join(outTs, "src", "TestConnector", "propertyTransformBase.ts"),
      "utf8"
    );
    expect(tsTransforms).toContain("validateString");
    expect(tsTransforms).toContain("^PRJ-[0-9]+$");

    const csTransforms = await readFile(
      path.join(outDotnet, "TestConnector", "PropertyTransformBase.cs"),
      "utf8"
    );
    expect(csTransforms).toContain("ValidateString");
    expect(csTransforms).toContain("^PRJ-[0-9]+$");

    const csModel = await readFile(path.join(outDotnet, "TestConnector", "Model.cs"), "utf8");
    expect(csModel).toContain("Example item");
    expect(csModel).toContain("Display title");
  });

  test("init projects emit exact match search and date-time validation", async () => {
    const tspPath = await writeTempTspFile(`
      @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" })
      @coco.item
      model Item {
        @coco.id
        id: string;

        @coco.search({ exactMatchRequired: true })
        code: string;

        @pattern("^PRJ-[0-9]+$")
        @example("PRJ-1001")
        ticketId: string;

        @example(42)
        count: int64;

        @minValue(1)
        total: int64;

        @maxValue(10)
        rating: float64;

        @example(true)
        active: boolean;

        @example(#["alpha", "beta"])
        tags: string[];
      }
    `);

    const outRoot = await writeTempDir();
    const outTs = path.join(outRoot, "example-ts-coverage");
    const outDotnet = path.join(outRoot, "example-dotnet-coverage");

    await initTsProject({ tspPath, outDir: outTs, force: false });
    await initDotnetProject({ tspPath, outDir: outDotnet, force: false });

    const csv = await readFile(path.join(outTs, "data.csv"), "utf8");
    expect(csv).toContain("42");
    expect(csv).toContain("true");
    expect(csv).toContain("alpha;beta");

    const csTransforms = await readFile(
      path.join(outDotnet, "TestConnector", "PropertyTransformBase.cs"),
      "utf8"
    );
    expect(csTransforms).toContain("ValidateInt64");
    expect(csTransforms).toContain("ValidateDouble");

    const csSchemaPayload = await readFile(
      path.join(outDotnet, "TestConnector", "SchemaPayload.cs"),
      "utf8"
    );
    expect(csSchemaPayload).toContain("IsExactMatchRequired = true");
  });
});
