import { describe, expect, test } from "vitest";
import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";

import {
  initDotnetProject,
  initRestProject,
  initTsProject,
  updateDotnetProject,
  updateProject,
  updateRestProject,
  updateTsProject,
} from "../../src/init/init.js";
import { writeTempDir, writeTempTspFile } from "../test-utils.js";

const peopleSchema = `using coco;

@coco.connection({
  contentCategory: "people",
  name: "People connector",
  connectionId: "peopleconnector",
  connectionDescription: "People connector generated by cocogen"
})
@coco.profileSource({
  webUrl: "https://example.com",
  displayName: "Example people source"
})
@coco.item
model Person {
  @coco.id
  @coco.label("personAccount")
  @coco.source("upn", "userPrincipalName")
  id: string;
}
`;

describe("init errors", () => {
  test("fails when output directory is not empty", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "non-empty");
    await mkdir(outDir, { recursive: true });
    await writeFile(path.join(outDir, "existing.txt"), "hi", "utf8");

    await expect(initTsProject({ tspPath, outDir, force: false })).rejects.toThrow(/not empty/i);
  });

  test("allows force in non-empty output directory", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "non-empty-force");
    await mkdir(outDir, { recursive: true });
    await writeFile(path.join(outDir, "existing.txt"), "hi", "utf8");

    const result = await initTsProject({ tspPath, outDir, force: true });
    expect(result.outDir).toBe(outDir);
  });

  test("fails when preview features are required", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-project");

    await expect(initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: false })).rejects.toThrow(
      /use-preview-features/i
    );
  });

  test("dotnet init fails when preview features are required", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-dotnet");

    await expect(initDotnetProject({ tspPath, outDir, force: false, usePreviewFeatures: false })).rejects.toThrow(
      /use-preview-features/i
    );
  });

  test("rest init fails when preview features are required", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-rest");

    await expect(initRestProject({ tspPath, outDir, force: false, usePreviewFeatures: false })).rejects.toThrow(
      /use-preview-features/i
    );
  });

  test("dotnet init fails when schema validation fails", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: int64; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-invalid-schema");

    await expect(initDotnetProject({ tspPath, outDir, force: false })).rejects.toThrow(/Schema validation failed/i);
  });

  test("rest init fails when schema validation fails", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: int64; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "rest-invalid-schema");

    await expect(initRestProject({ tspPath, outDir, force: false })).rejects.toThrow(/Schema validation failed/i);
  });

  test("updateDotnetProject rejects non-dotnet project", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-project");

    await initTsProject({ tspPath, outDir, force: false });

    await expect(updateDotnetProject({ outDir })).rejects.toThrow(/Use cocogen generate\/update for that language/i);
  });

  test("updateRestProject rejects non-rest project", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-project-rest");

    await initTsProject({ tspPath, outDir, force: false });

    await expect(updateRestProject({ outDir })).rejects.toThrow(/Use cocogen generate\/update for that language/i);
  });

  test("updateTsProject rejects dotnet project", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-project");

    await initDotnetProject({ tspPath, outDir, force: false });

    await expect(updateTsProject({ outDir })).rejects.toThrow(/Use cocogen generate\/update for that language/i);
  });

  test("updateTsProject fails when preview features are required", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-update");

    await initTsProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    await expect(updateTsProject({ outDir, usePreviewFeatures: false })).rejects.toThrow(/use-preview-features/i);
  });

  test("updateRestProject fails when preview features are required", async () => {
    const tspPath = await writeTempTspFile(peopleSchema);
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "people-rest-update");

    await initRestProject({ tspPath, outDir, force: false, usePreviewFeatures: true });

    await expect(updateRestProject({ outDir, usePreviewFeatures: false })).rejects.toThrow(/use-preview-features/i);
  });

  test("updateDotnetProject fails when schema validation fails", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "dotnet-invalid");

    await initDotnetProject({ tspPath, outDir, force: false });

    await writeFile(
      path.join(outDir, "schema.tsp"),
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: int64; }`,
      "utf8"
    );

    await expect(updateDotnetProject({ outDir })).rejects.toThrow(/Schema validation failed/i);
  });

  test("updateRestProject fails when schema validation fails", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "rest-invalid-update");

    await initRestProject({ tspPath, outDir, force: false });

    await writeFile(
      path.join(outDir, "schema.tsp"),
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: int64; }`,
      "utf8"
    );

    await expect(updateRestProject({ outDir })).rejects.toThrow(/Schema validation failed/i);
  });

  test("updateTsProject fails when schema validation fails", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: string; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "ts-invalid-update");

    await initTsProject({ tspPath, outDir, force: false });

    await writeFile(
      path.join(outDir, "schema.tsp"),
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: int64; }`,
      "utf8"
    );

    await expect(updateTsProject({ outDir })).rejects.toThrow(/Schema validation failed/i);
  });

  test("fails when schema validation fails", async () => {
    const tspPath = await writeTempTspFile(
      `using coco; @coco.connection({ name: "Test connector", connectionId: "testconnection", connectionDescription: "Test connector" }) @coco.item model Item { @coco.id id: int64; }`
    );
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "invalid-schema");

    await expect(initTsProject({ tspPath, outDir, force: false })).rejects.toThrow(/Schema validation failed/i);
  });

  test("updateProject fails when cocogen.json is missing", async () => {
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "missing-config");
    await mkdir(outDir, { recursive: true });

    await expect(updateProject({ outDir })).rejects.toThrow(/Missing cocogen.json/i);
  });

  test("updateProject fails on invalid cocogen.json", async () => {
    const outRoot = await writeTempDir();
    const outDir = path.join(outRoot, "invalid-config");
    await mkdir(outDir, { recursive: true });
    await writeFile(path.join(outDir, "cocogen.json"), JSON.stringify({ lang: "go" }, null, 2), "utf8");

    await expect(updateProject({ outDir })).rejects.toThrow(/Invalid cocogen.json/i);
  });
});
