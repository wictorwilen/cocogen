import path from "node:path";
import { fileURLToPath } from "node:url";
import { writeFile, readFile } from "node:fs/promises";
import { describe, expect, test } from "vitest";

import { runCommand, runNode, writeTempTspFile } from "../test-utils.js";

const repoRoot = path.resolve(path.dirname(fileURLToPath(import.meta.url)), "../..");

function distCliPath(): string {
  return path.join(repoRoot, "dist", "cli.js");
}

const peopleSchema = `
  using coco;

  @coco.connection({
    contentCategory: "people",
    graphApiVersion: "beta",
    name: "People connector",
    connectionId: "peopleconnector",
    connectionDescription: "People connector generated by cocogen"
  })
  @coco.profileSource({
    webUrl: "https://example.com/people",
    displayName: "Example People Directory"
  })
  @coco.item()
  model PersonProfile {
    @coco.id
    @coco.label("personAccount")
    @coco.source("upn", "userPrincipalName")
    userPrincipalName: string;

    @coco.label("personName")
    @coco.source("displayName", "displayName")
    displayName: string;

    @coco.label("personEmails")
    @coco.source("email", "address")
    @coco.source("emailType", "type")
    emails: string[];
  }
`;

describe("people label serialization (e2e)", () => {
  test("ts output rejects invalid people payloads", async () => {
    const entry = await writeTempTspFile(peopleSchema);
    const outDir = path.join(path.dirname(entry), "out-people-ts");

    const init = await runNode([
      distCliPath(),
      "generate",
      "--lang",
      "ts",
      "--tsp",
      entry,
      "--out",
      outDir,
      "--use-preview-features",
    ], {
      cwd: repoRoot,
      env: { NO_COLOR: "1", CI: "1" },
    });

    expect(init.code).toBe(0);

    const scriptPath = path.join(outDir, "people-serialization-check.ts");
    await writeFile(
      scriptPath,
      [
        "import { serializePersonName, serializePersonEmails } from './src/core/people.ts';",
        "const assertThrows = (fn, label) => {",
        "  try { fn(); throw new Error('no-error'); } catch (err) {",
        "    if (err instanceof Error && err.message === 'no-error') throw err;",
        "  }",
        "};",
        "assertThrows(() => serializePersonName({}), 'personName');",
        "assertThrows(() => serializePersonName({ id: 'should-not-send' }), 'personName');",
        "assertThrows(() => serializePersonName({ createdDateTime: '2024-01-01T00:00:00Z' }), 'personName');",
        "assertThrows(() => serializePersonEmails(['not-json']), 'personEmails');",
        "console.log('ok');",
      ].join("\n"),
      "utf8"
    );

    const tsxBin = path.join(repoRoot, "node_modules", ".bin", process.platform === "win32" ? "tsx.cmd" : "tsx");
    const run = await runCommand(tsxBin, [scriptPath], {
      cwd: outDir,
      env: { NO_COLOR: "1", CI: "1" },
    });

    expect(run.code).toBe(0);

    const peopleTs = await readFile(path.join(outDir, "src", "core", "people.ts"), "utf8");
    expect(peopleTs).toContain("type PersonRelationship");
  });

  test("dotnet output includes JSON enforcement for people payloads", async () => {
    const entry = await writeTempTspFile(peopleSchema);
    const outDir = path.join(path.dirname(entry), "out-people-dotnet");

    const init = await runNode([
      distCliPath(),
      "generate",
      "--lang",
      "dotnet",
      "--tsp",
      entry,
      "--out",
      outDir,
      "--use-preview-features",
    ], {
      cwd: repoRoot,
      env: { NO_COLOR: "1", CI: "1" },
    });

    expect(init.code).toBe(0);

    const payload = await readFile(path.join(outDir, "Core", "PeoplePayload.cs"), "utf8");
    expect(payload).toContain("non-empty JSON string");
    expect(payload).toContain("read-only");
    expect(payload).toContain("enum PersonRelationship");
    expect(payload).toContain("JsonStringEnumConverter");
  });
});
