import { writeFile } from "node:fs/promises";
import path from "node:path";

import type { ConnectorIr } from "../ir.js";
import { loadIrFromTypeSpec } from "../tsp/loader.js";
import { validateIr } from "../validate/validator.js";
import { graphBaseUrl, schemaPayload, toOdataCollectionType } from "./helpers/schema.js";
import {
  COCOGEN_CONFIG_FILE,
  loadProjectConfig,
  projectConfigContents,
} from "./project-config.js";
import {
  buildSampleCsv,
  buildSampleJson,
  buildSamplePersonEntityPayload,
  buildSampleYaml,
  exampleValueForPayload,
  samplePayloadValueForType,
} from "./sample-data.js";
import { renderTemplate } from "./template.js";
import { ensureEmptyDir, updateSchemaCopy } from "./helpers/fs.js";
import { TsGenerator } from "./ts/generator.js";
import { DotnetGenerator } from "./dotnet/generator.js";

export type InitOptions = {
  tspPath: string;
  outDir: string;
  projectName?: string;
  force?: boolean;
  usePreviewFeatures?: boolean;
  inputFormat?: "csv" | "json" | "yaml" | "rest" | "custom" | undefined;
};

export type UpdateOptions = {
  outDir: string;
  tspPath?: string;
  usePreviewFeatures?: boolean;
};

/** Build the REST connection payload from the IR. */
function buildRestConnectionPayload(ir: ConnectorIr): Record<string, unknown> {
  const payload: Record<string, unknown> = {
    id: ir.connection.connectionId ?? "connection-id",
    name: ir.connection.connectionName ?? "Connector",
    description: ir.connection.connectionDescription ?? "Connector generated by cocogen",
  };
  if (ir.connection.contentCategory) {
    payload.contentCategory = ir.connection.contentCategory;
  }
  return payload;
}

/** Build the REST item payload from the IR and item id. */
function buildRestItemPayload(ir: ConnectorIr, itemId: string): Record<string, unknown> {
  const properties: Record<string, unknown> = {};
  for (const prop of ir.properties) {
    if (prop.name === ir.item.contentPropertyName) continue;
    const exampleValue = exampleValueForPayload(prop.example, prop.type);
    if (prop.personEntity && prop.type !== "principal" && prop.type !== "principalCollection") {
      const isCollection = prop.type.endsWith("Collection");
      properties[prop.name] = buildSamplePersonEntityPayload(prop.personEntity.fields, isCollection);
    } else {
      const value =
        exampleValue ??
        samplePayloadValueForType(
          prop.type,
          prop.personEntity ? prop.personEntity.fields : null,
          prop.source
        );
      properties[prop.name] = value;
    }

    const odataType = toOdataCollectionType(prop.type);
    if (odataType) {
      properties[`${prop.name}@odata.type`] = odataType;
    }
  }

  const payload: Record<string, unknown> = {
    id: itemId,
    acl: [{ type: "everyone", value: "everyone", accessType: "grant" }],
    properties,
  };

  if (ir.item.contentPropertyName) {
    const contentProp = ir.properties.find((p) => p.name === ir.item.contentPropertyName);
    const exampleValue = contentProp ? exampleValueForPayload(contentProp.example, contentProp.type) : undefined;
    const value = exampleValue ?? "Sample content";
    payload.content = { type: ir.item.contentType ?? "text", value: String(value) };
  }

  return payload;
}

/** Write REST sample request files for a generated project. */
async function writeRestFiles(outDir: string, ir: ConnectorIr): Promise<void> {
  const connectionId = ir.connection.connectionId ?? "connection-id";
  const connectionPayloadJson = JSON.stringify(buildRestConnectionPayload(ir), null, 2);
  const schemaPayloadJson = JSON.stringify(schemaPayload(ir), null, 2);

  const idProp = ir.properties.find((p) => p.name === ir.item.idPropertyName);
  const idExample = idProp ? exampleValueForPayload(idProp.example, idProp.type) : undefined;
  const itemId =
    typeof idExample === "string"
      ? idExample
      : Array.isArray(idExample)
      ? String(idExample[0] ?? "sample-id")
      : idExample !== undefined && idExample !== null
      ? String(idExample)
      : "sample-id";

  const itemPayloadJson = JSON.stringify(buildRestItemPayload(ir, itemId), null, 2);

  await writeFile(
    path.join(outDir, "create-connection.http"),
    await renderTemplate("rest/create-connection.http.ejs", {
      graphBaseUrl: graphBaseUrl(ir),
      connectionId,
      connectionPayloadJson,
    }),
    "utf8"
  );

  await writeFile(
    path.join(outDir, "patch-schema.http"),
    await renderTemplate("rest/patch-schema.http.ejs", {
      graphBaseUrl: graphBaseUrl(ir),
      connectionId,
      schemaPayloadJson,
    }),
    "utf8"
  );

  await writeFile(
    path.join(outDir, "ingest-item.http"),
    await renderTemplate("rest/ingest-item.http.ejs", {
      graphBaseUrl: graphBaseUrl(ir),
      connectionId,
      itemId,
      itemPayloadJson,
    }),
    "utf8"
  );

  if (ir.connection.contentCategory === "people") {
    const profileSourceWebUrl = ir.connection.profileSource?.webUrl ?? "https://example.com/people";
    const profileSourceDisplayName =
      ir.connection.profileSource?.displayName ?? ir.connection.connectionName ?? ir.item.typeName;
    const profileSourcePriority = ir.connection.profileSource?.priority ?? "first";

    await writeFile(
      path.join(outDir, "profile-source.http"),
      await renderTemplate("rest/profile-source.http.ejs", {
        graphBaseUrl: graphBaseUrl(ir),
        connectionId,
        profileSourceWebUrl,
        profileSourceDisplayName,
        profileSourcePriority,
      }),
      "utf8"
    );
  }
}

/** Format validation errors into a single error message. */
function formatValidationErrors(ir: ConnectorIr): string {
  const issues = validateIr(ir);
  const errors = issues.filter((i) => i.severity === "error");
  if (errors.length === 0) return "";

  return errors
    .map((e) => `- ${e.message}${e.hint ? `\n  hint: ${e.hint}` : ""}`)
    .join("\n");
}

/** Update an existing TS project from a schema. */
export async function updateTsProject(options: UpdateOptions): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  const { config } = await loadProjectConfig(outDir);
  const tspPath = options.tspPath ? path.resolve(options.tspPath) : path.resolve(outDir, config.tsp);

  if (config.lang !== "ts") {
    throw new Error(`This project is '${config.lang}'. Use cocogen generate/update for that language.`);
  }

  const ir = await loadIrFromTypeSpec(tspPath, { inputFormat: config.inputFormat });
  if (ir.connection.graphApiVersion === "beta" && !options.usePreviewFeatures) {
    throw new Error("This schema requires Graph beta. Re-run with --use-preview-features.");
  }
  const validationMessage = formatValidationErrors(ir);
  if (validationMessage) {
    throw new Error(`Schema validation failed:\n${validationMessage}`);
  }

  await updateSchemaCopy(outDir, tspPath);

  const generator = new TsGenerator({
    outDir,
    ir,
    settings: { projectName: path.basename(outDir), tspPath },
  });
  await generator.writeGenerated();

  if (options.tspPath) {
    await writeFile(
      path.join(outDir, COCOGEN_CONFIG_FILE),
      projectConfigContents(outDir, tspPath, "ts", config.inputFormat),
      "utf8"
    );
  }

  return { outDir, ir };
}

/** Update an existing .NET project from a schema. */
export async function updateDotnetProject(
  options: UpdateOptions
): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  const { config } = await loadProjectConfig(outDir);
  const tspPath = options.tspPath ? path.resolve(options.tspPath) : path.resolve(outDir, config.tsp);

  if (config.lang !== "dotnet") {
    throw new Error(`This project is '${config.lang}'. Use cocogen generate/update for that language.`);
  }

  const ir = await loadIrFromTypeSpec(tspPath, { inputFormat: config.inputFormat });
  if (ir.connection.graphApiVersion === "beta" && !options.usePreviewFeatures) {
    throw new Error("This schema requires Graph beta. Re-run with --use-preview-features.");
  }
  const validationMessage = formatValidationErrors(ir);
  if (validationMessage) {
    throw new Error(`Schema validation failed:\n${validationMessage}`);
  }

  await updateSchemaCopy(outDir, tspPath);

  const generator = new DotnetGenerator({
    outDir,
    ir,
    settings: { projectName: path.basename(outDir), tspPath },
  });
  await generator.writeGenerated();

  if (options.tspPath) {
    await writeFile(
      path.join(outDir, COCOGEN_CONFIG_FILE),
      projectConfigContents(outDir, tspPath, "dotnet", config.inputFormat),
      "utf8"
    );
  }

  return { outDir, ir };
}

/** Update an existing REST project from a schema. */
export async function updateRestProject(options: UpdateOptions): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  const { config } = await loadProjectConfig(outDir);
  const tspPath = options.tspPath ? path.resolve(options.tspPath) : path.resolve(outDir, config.tsp);

  if (config.lang !== "rest") {
    throw new Error(`This project is '${config.lang}'. Use cocogen generate/update for that language.`);
  }

  const ir = await loadIrFromTypeSpec(tspPath, { inputFormat: config.inputFormat });
  if (ir.connection.graphApiVersion === "beta" && !options.usePreviewFeatures) {
    throw new Error("This schema requires Graph beta. Re-run with --use-preview-features.");
  }
  const validationMessage = formatValidationErrors(ir);
  if (validationMessage) {
    throw new Error(`Schema validation failed:\n${validationMessage}`);
  }

  await updateSchemaCopy(outDir, tspPath);

  await writeRestFiles(outDir, ir);
  if (options.tspPath) {
    await writeFile(
      path.join(outDir, COCOGEN_CONFIG_FILE),
      projectConfigContents(outDir, tspPath, "rest", config.inputFormat),
      "utf8"
    );
  }

  return { outDir, ir };
}

/** Update an existing project based on its cocogen config. */
export async function updateProject(options: UpdateOptions): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  const { config } = await loadProjectConfig(outDir);
  if (config.lang === "dotnet") {
    return updateDotnetProject(options);
  }
  if (config.lang === "rest") {
    return updateRestProject(options);
  }
  return updateTsProject(options);
}

/** Initialize a REST-only project from a schema. */
export async function initRestProject(options: InitOptions): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  await ensureEmptyDir(outDir, Boolean(options.force));

  const ir = await loadIrFromTypeSpec(options.tspPath, { inputFormat: options.inputFormat });
  if (ir.connection.graphApiVersion === "beta" && !options.usePreviewFeatures) {
    throw new Error("This schema requires Graph beta. Re-run with --use-preview-features.");
  }
  const validationMessage = formatValidationErrors(ir);
  if (validationMessage) {
    throw new Error(`Schema validation failed:\n${validationMessage}`);
  }

  const copiedTspPath = path.join(outDir, "schema.tsp");
  await updateSchemaCopy(outDir, path.resolve(options.tspPath));
  await writeFile(
    path.join(outDir, COCOGEN_CONFIG_FILE),
    projectConfigContents(outDir, copiedTspPath, "rest", ir.connection.inputFormat),
    "utf8"
  );

  await writeRestFiles(outDir, ir);
  return { outDir, ir };
}

/** Initialize a TS project from a schema. */
export async function initTsProject(options: InitOptions): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  await ensureEmptyDir(outDir, Boolean(options.force));

  const ir = await loadIrFromTypeSpec(options.tspPath, { inputFormat: options.inputFormat });
  if (ir.connection.graphApiVersion === "beta" && !options.usePreviewFeatures) {
    throw new Error("This schema requires Graph beta. Re-run with --use-preview-features.");
  }
  const validationMessage = formatValidationErrors(ir);
  if (validationMessage) {
    throw new Error(`Schema validation failed:\n${validationMessage}`);
  }

  const projectName = options.projectName ?? path.basename(outDir);
  const copiedTspPath = path.join(outDir, "schema.tsp");
  await updateSchemaCopy(outDir, path.resolve(options.tspPath));

  const generator = new TsGenerator({
    outDir,
    ir,
    settings: { projectName, tspPath: copiedTspPath },
  });
  await generator.writeScaffold();

  if (ir.connection.inputFormat === "json") {
    await writeFile(path.join(outDir, "data.json"), buildSampleJson(ir), "utf8");
  } else if (ir.connection.inputFormat === "yaml") {
    await writeFile(path.join(outDir, "data.yaml"), buildSampleYaml(ir), "utf8");
  } else if (ir.connection.inputFormat === "csv") {
    await writeFile(path.join(outDir, "data.csv"), buildSampleCsv(ir), "utf8");
  }

  await generator.writeGenerated();

  return { outDir, ir };
}

/** Initialize a .NET project from a schema. */
export async function initDotnetProject(
  options: InitOptions
): Promise<{ outDir: string; ir: ConnectorIr }> {
  const outDir = path.resolve(options.outDir);
  await ensureEmptyDir(outDir, Boolean(options.force));

  const ir = await loadIrFromTypeSpec(options.tspPath, { inputFormat: options.inputFormat });
  if (ir.connection.graphApiVersion === "beta" && !options.usePreviewFeatures) {
    throw new Error("This schema requires Graph beta. Re-run with --use-preview-features.");
  }
  const validationMessage = formatValidationErrors(ir);
  if (validationMessage) {
    throw new Error(`Schema validation failed:\n${validationMessage}`);
  }

  const projectName = options.projectName ?? path.basename(outDir);
  const copiedTspPath = path.join(outDir, "schema.tsp");
  await updateSchemaCopy(outDir, path.resolve(options.tspPath));

  const generator = new DotnetGenerator({
    outDir,
    ir,
    settings: { projectName, tspPath: copiedTspPath },
  });
  await generator.writeScaffold();

  if (ir.connection.inputFormat === "json") {
    await writeFile(path.join(outDir, "data.json"), buildSampleJson(ir), "utf8");
  } else if (ir.connection.inputFormat === "yaml") {
    await writeFile(path.join(outDir, "data.yaml"), buildSampleYaml(ir), "utf8");
  } else if (ir.connection.inputFormat === "csv") {
    await writeFile(path.join(outDir, "data.csv"), buildSampleCsv(ir), "utf8");
  }

  await generator.writeGenerated();

  return { outDir, ir };
}
