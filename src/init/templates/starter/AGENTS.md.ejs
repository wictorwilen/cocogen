# AGENTS.md

This file is the working agreement for humans and coding agents contributing to this connector schema.

## Quick start

1. Edit your schema (for example: `schema.tsp`).
2. Validate: `npx cocogen validate --tsp schema.tsp`
3. Generate a runnable connector project: `npx cocogen generate --tsp schema.tsp --out ./out --lang ts`

> Tip: If `cocogen` isn't on your PATH, use `npx @wictorwilen/cocogen ...`.

## How to write a schema

A schema is a TypeSpec file that describes:
- Connection metadata (name/id/description)
- A single primary item model (the thing Copilot searches)
- Field mappings from your datasource into Graph

Minimum shape:

```tsp
import "@wictorwilen/cocogen";
using coco;

@coco.connection({
  name: "Content connector",
  connectionId: "contentconnector",
  connectionDescription: "Content connector generated by cocogen"
})

@coco.item()
model Item {
  @coco.id
  id: string;
}
```

### Common building blocks

- **Connection**: `@coco.connection({ ... })` sets the identity and UX description of the connector.
- **Item model**: `@coco.item()` marks the primary searchable entity.
- **ID**: exactly one property should be marked with `@coco.id`. It must be stable across updates.
- **Labels**: use `@coco.label("...")` to help Copilot understand field meaning (title, url, personName, etc).
- **Source mapping**: use `@coco.source("column" [, "entity.path"])` to map from your datasource.
- **Searchability**: use `@coco.search({ searchable: true, retrievable: true })` for fields you want searchable/retrievable.

### Content connector example

```tsp
import "@wictorwilen/cocogen";
using coco;

@coco.connection({
  name: "Contoso Knowledge Base",
  connectionId: "contosokb",
  connectionDescription: "KB articles for support"
})

@coco.item()
model Article {
  @coco.id
  @coco.source("id")
  id: string;

  @coco.label("title")
  @coco.search({ searchable: true, retrievable: true })
  @coco.source("title")
  title: string;

  @coco.label("url")
  @coco.source("url")
  url: string;

  @coco.search({ searchable: true, retrievable: true })
  @coco.source("summary")
  summary: string;

  @coco.content({ type: "text" })
  @coco.source("body")
  body: string;
}
```

## Best practices

- Keep the schema small and explicit; prefer fewer high-quality fields over many ambiguous ones.
- Use a **stable ID** (do not use row numbers or timestamps).
- Mark a **title** field and include a **url** when possible.
- Include a single `@coco.content` field for full-text retrieval when you have it (content connectors only).
- Map fields with `@coco.source` even when names match; it documents intent and reduces surprises when headers change.
- Validate early and often (see below).

## Type hints (non-blocking)

These are helpful defaults, not strict requirements:

- When you reference a person, use `Principal`.
- For multi-value strings (tags, skills, aliases), use `StringCollection`.
- Stick to the supported scalar types in the TypeSpec docs for your connector kind.
- Optional (`?`) properties are not supported and will produce validation errors.

## Validation (cocogen validate)

Run validation locally:

- `npx cocogen validate --tsp schema.tsp`

Optional flags:
- `--data-format csv|json|yaml|rest|custom` (matches what you intend to generate)
- `--json` for machine-readable output (CI-friendly)

Exit codes:
- `0` when there are no validation errors
- `1` when validation errors exist

Common fixes:
- Missing `@coco.connection` → add connection metadata at top level
- Missing or multiple `@coco.id` → ensure exactly one stable ID field
- Optional properties → make required (connectors require non-optional schema properties)
- People schemas without preview flag → re-run with `--use-preview-features`

<% if (kind === "people") { %>
## People connectors (preview)

People connectors use Microsoft Graph **/beta**.

- Always validate/generate with: `--use-preview-features`
- Expect breaking changes as Graph beta evolves
<% } %>
