// Connector CLI for provisioning, ingestion, and deletion.
using Azure.Core;
using Azure.Identity;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.UserSecrets;
<% if (graphApiVersion === "beta") { -%>
using Microsoft.Graph.Beta;
<% } else { -%>
using Microsoft.Graph;
<% } -%>
using System.CommandLine;
using System.Threading;

using <%= namespaceName %>.Core;
using <%= namespaceName %>.Datasource;
using <%= schemaNamespace %>;

var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional: true)
    .AddJsonFile("appsettings.Development.json", optional: true)
    .AddUserSecrets<Program>(optional: true)
    .AddEnvironmentVariables()
    .Build();

bool UseColor() => string.IsNullOrWhiteSpace(Environment.GetEnvironmentVariable("NO_COLOR"));

void PrintBanner()
{
    var title = "âœ¨ ðŸ¥¥ <%= itemTypeName %> connector CLI ðŸ¥¥ âœ¨";
    var subtitle = "Provision â€¢ Ingest â€¢ Delete";
    if (UseColor())
    {
        var original = Console.ForegroundColor;
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine(title);
        Console.ForegroundColor = ConsoleColor.DarkGray;
        Console.WriteLine(subtitle);
        Console.ForegroundColor = original;
    }
    else
    {
        Console.WriteLine(title);
        Console.WriteLine(subtitle);
    }
}

PrintBanner();

/// <summary>
/// Resolve a required configuration value or throw a friendly error.
/// </summary>
string RequiredSetting(string key, string? fallback = null)
{
    var value = configuration[key];
    if (string.IsNullOrWhiteSpace(value))
        value = fallback;
    if (string.IsNullOrWhiteSpace(value))
    {
        var envKey = key.Replace(":", "__");
        throw new InvalidOperationException(
            $"Missing configuration: {key}. Set '{key}' in appsettings.json or set the env var '{envKey}'."
        );
    }
    return value;
}

string ConnectionId() => RequiredSetting("Connection:Id", SchemaConstants.ConnectionId);
string ConnectionName() => RequiredSetting("Connection:Name", SchemaConstants.ConnectionName);
string ConnectionDescription() => RequiredSetting("Connection:Description", SchemaConstants.ConnectionDescription);
<% if (isPeopleConnector) { -%>
string ProfileSourceWebUrl() => RequiredSetting("ProfileSource:WebUrl", SchemaConstants.ProfileSourceWebUrl);
string ProfileSourceDisplayName() => RequiredSetting("ProfileSource:DisplayName", SchemaConstants.ProfileSourceDisplayName);
string ProfileSourcePriority()
{
    var raw = configuration["ProfileSource:Priority"];
    if (string.IsNullOrWhiteSpace(raw))
        raw = SchemaConstants.ProfileSourcePriority;
    if (string.IsNullOrWhiteSpace(raw))
        raw = "first";
    var value = raw.Trim().ToLowerInvariant();
    if (value is not "first" and not "last")
        throw new InvalidOperationException("ProfileSource:Priority must be 'first' or 'last'.");
    return value;
}
<% } -%>

/// <summary>
/// Create an app-only credential for Microsoft Graph.
/// </summary>
TokenCredential CreateCredential()
{
    var managedIdentityClientId = configuration["AzureAd:ManagedIdentityClientId"];
    TokenCredential managedIdentity = string.IsNullOrWhiteSpace(managedIdentityClientId)
        ? new ManagedIdentityCredential()
        : new ManagedIdentityCredential(managedIdentityClientId);

    var tenantId = configuration["AzureAd:TenantId"];
    var clientId = configuration["AzureAd:ClientId"];
    var clientSecret = configuration["AzureAd:ClientSecret"];

    if (string.IsNullOrWhiteSpace(tenantId)
        && string.IsNullOrWhiteSpace(clientId)
        && string.IsNullOrWhiteSpace(clientSecret))
    {
        return managedIdentity;
    }

    if (string.IsNullOrWhiteSpace(tenantId)
        || string.IsNullOrWhiteSpace(clientId)
        || string.IsNullOrWhiteSpace(clientSecret))
    {
        throw new InvalidOperationException(
            "AzureAd settings are incomplete. Set TenantId, ClientId, and ClientSecret, or clear them to use managed identity."
        );
    }

    var clientSecretCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
    return new ChainedTokenCredential(managedIdentity, clientSecretCredential);
}

/// <summary>
/// Create a Graph client configured for the selected API version.
/// </summary>
GraphServiceClient CreateGraphClient()
{
    var credential = CreateCredential();
    var graph = new GraphServiceClient(credential, new[] { "https://graph.microsoft.com/.default" });
    graph.RequestAdapter.BaseUrl = SchemaConstants.GraphBaseUrl;
    return graph;
}

ConnectorCore BuildConnectorCore(GraphServiceClient? graph, TokenCredential? credential, string connectionId)
{
    return new ConnectorCore(
        graph,
        credential,
        connectionId,
        ConnectionName(),
        ConnectionDescription(),
        SchemaConstants.ContentCategory,
        <%- isPeopleConnector ? "ProfileSourceWebUrl()" : "null" %>,
        <%- isPeopleConnector ? "ProfileSourceDisplayName()" : "null" %>,
        <%- isPeopleConnector ? "ProfileSourcePriority()" : "null" %>
    );
}

/// <summary>
/// Provision the connection and schema (then profile source for people connectors).
/// </summary>
async Task ProvisionAsync()
{
    var graph = CreateGraphClient();
    var credential = CreateCredential();
    var connectionId = ConnectionId();
    var core = BuildConnectorCore(graph, credential, connectionId);

    await core.ProvisionAsync();
    Console.WriteLine("ok: connection + schema provisioned");
<% if (isPeopleConnector) { -%>
    await core.ProvisionProfileSourceAsync();
    Console.WriteLine("ok: profile source registered");
<% } -%>
    Console.WriteLine("ok: provisioned");
}

/// <summary>
/// Ingest items from CSV.
/// </summary>
async Task IngestAsync(string? csvPath, bool dryRun, int? limit, bool verbose, bool failFast)
{
    GraphServiceClient? graph = null;
    TokenCredential? credential = null;
    string connectionId = "dry-run";
    if (!dryRun)
    {
        graph = CreateGraphClient();
        credential = CreateCredential();
        connectionId = ConnectionId();
    }

    var configuredCsv = configuration["Csv:Path"] ?? "data.csv";
    var path = string.IsNullOrWhiteSpace(csvPath) ? configuredCsv : csvPath;

    // Swap this for any IItemSource implementation (API, DB, queue, etc.).
    IItemSource source = new CsvItemSource(path);
    var core = BuildConnectorCore(graph, credential, connectionId);

    await core.IngestAsync(source, dryRun, limit, verbose, failFast);
}

/// <summary>
/// Delete the external connection.
/// </summary>
async Task DeleteConnectionAsync()
{
    var graph = CreateGraphClient();
    var credential = CreateCredential();
    var connectionId = ConnectionId();
    var core = BuildConnectorCore(graph, credential, connectionId);

    await core.DeleteConnectionAsync();
    Console.WriteLine("ok: deleted");
}

var csvOption = new Option<string>("--csv", description: "CSV path");
var dryRunOption = new Option<bool>("--dry-run", description: "Build payloads but do not send to Graph");
var failFastOption = new Option<bool>("--fail-fast", description: "Abort on the first item failure");
var limitOption = new Option<int?>("--limit", description: "Limit number of items");
var verboseOption = new Option<bool>("--verbose", description: "Print payloads sent to Graph");

var root = new RootCommand("Connector CLI generated by cocogen");

var provisionCommand = new Command("provision", "Create or update the connection and schema");
provisionCommand.SetHandler(async () => await ProvisionAsync());

var ingestCommand = new Command("ingest", "Ingest items from CSV");
ingestCommand.AddOption(csvOption);
ingestCommand.AddOption(dryRunOption);
ingestCommand.AddOption(failFastOption);
ingestCommand.AddOption(limitOption);
ingestCommand.AddOption(verboseOption);
ingestCommand.SetHandler(
    async (string? csv, bool dryRun, bool failFast, int? limit, bool verbose) => await IngestAsync(csv, dryRun, limit, verbose, failFast),
    csvOption,
    dryRunOption,
    failFastOption,
    limitOption,
    verboseOption
);

var deleteCommand = new Command("delete", "Delete the connection");
deleteCommand.SetHandler(async () => await DeleteConnectionAsync());

root.AddCommand(provisionCommand);
root.AddCommand(ingestCommand);
root.AddCommand(deleteCommand);

<% if (isPeopleConnector) { -%>
var registerCommand = new Command("register-profile-source", "Register the connection as a profile source");
registerCommand.SetHandler(async () =>
{
    var graph = CreateGraphClient();
    var credential = CreateCredential();
    var connectionId = ConnectionId();
    var core = BuildConnectorCore(graph, credential, connectionId);
    await core.ProvisionProfileSourceAsync();
});
root.AddCommand(registerCommand);
<% } -%>

try
{
    return await root.InvokeAsync(args);
}
catch (Exception ex)
{
    Console.Error.WriteLine("error: " + ex.Message);
    return 1;
}
