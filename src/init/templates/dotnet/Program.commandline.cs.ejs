// Connector CLI for provisioning, ingestion, and deletion.
using Azure.Core;
using Azure.Identity;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.UserSecrets;
<% if (graphApiVersion === "beta") { -%>
using Microsoft.Graph.Beta;
<% } else { -%>
using Microsoft.Graph;
<% } -%>
using System.CommandLine;
using System.Threading;

using <%= namespaceName %>.Core;
using <%= namespaceName %>.Datasource;
using <%= schemaNamespace %>;
using ItemModel = <%= schemaNamespace %>.<%= itemTypeName %>;

var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional: true)
    .AddJsonFile("appsettings.Development.json", optional: true)
    .AddUserSecrets<Program>(optional: true)
    .AddEnvironmentVariables()
    .Build();

bool UseColor() => string.IsNullOrWhiteSpace(Environment.GetEnvironmentVariable("NO_COLOR"));

void PrintBanner()
{
    var title = "âœ¨ ðŸ¥¥ <%= itemTypeName %> connector CLI ðŸ¥¥ âœ¨";
    var subtitle = "Provision â€¢ Ingest â€¢ Delete";
    if (UseColor())
    {
        var original = Console.ForegroundColor;
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine(title);
        Console.ForegroundColor = ConsoleColor.DarkGray;
        Console.WriteLine(subtitle);
        Console.ForegroundColor = original;
    }
    else
    {
        Console.WriteLine(title);
        Console.WriteLine(subtitle);
    }
}

PrintBanner();

/// <summary>
/// Resolve a required configuration value or throw a friendly error.
/// </summary>
string RequiredSetting(string key, string? fallback = null)
{
    var value = configuration[key];
    if (string.IsNullOrWhiteSpace(value))
        value = fallback;
    if (string.IsNullOrWhiteSpace(value))
    {
        var envKey = key.Replace(":", "__");
        throw new InvalidOperationException(
            $"Missing configuration: {key}. Set '{key}' in appsettings.json or set the env var '{envKey}'."
        );
    }
    return value;
}

string ConnectionId() => RequiredSetting("Connection:Id", SchemaConstants.ConnectionId);
string ConnectionName() => RequiredSetting("Connection:Name", SchemaConstants.ConnectionName);
string ConnectionDescription() => RequiredSetting("Connection:Description", SchemaConstants.ConnectionDescription);

string InputPath(string? inputPath)
{
    if (!string.IsNullOrWhiteSpace(inputPath)) return inputPath;
    return <%= JSON.stringify(inputFormat === "custom" ? "" : inputFormat === "json" ? "data.json" : inputFormat === "yaml" ? "data.yaml" : "data.csv") %>;
}
<% if (isPeopleConnector) { -%>
string ProfileSourceWebUrl() => RequiredSetting("ProfileSource:WebUrl", SchemaConstants.ProfileSourceWebUrl);
string ProfileSourceDisplayName() => RequiredSetting("ProfileSource:DisplayName", SchemaConstants.ProfileSourceDisplayName);
string ProfileSourcePriority()
{
    var raw = configuration["ProfileSource:Priority"];
    if (string.IsNullOrWhiteSpace(raw))
        raw = SchemaConstants.ProfileSourcePriority;
    if (string.IsNullOrWhiteSpace(raw))
        raw = "first";
    var value = raw.Trim().ToLowerInvariant();
    if (value is not "first" and not "last")
        throw new InvalidOperationException("ProfileSource:Priority must be 'first' or 'last'.");
    return value;
}
<% } -%>

/// <summary>
/// Create an app-only credential for Microsoft Graph.
/// </summary>
TokenCredential CreateCredential()
{
    var tenantId = configuration["AzureAd:TenantId"];
    var clientId = configuration["AzureAd:ClientId"];
    var clientSecret = configuration["AzureAd:ClientSecret"];

    if (string.IsNullOrWhiteSpace(tenantId)
        && string.IsNullOrWhiteSpace(clientId)
        && string.IsNullOrWhiteSpace(clientSecret))
    {
        var managedIdentityClientId = configuration["AzureAd:ManagedIdentityClientId"];
        return string.IsNullOrWhiteSpace(managedIdentityClientId)
            ? new ManagedIdentityCredential()
            : new ManagedIdentityCredential(managedIdentityClientId);
    }

    if (string.IsNullOrWhiteSpace(tenantId)
        || string.IsNullOrWhiteSpace(clientId)
        || string.IsNullOrWhiteSpace(clientSecret))
    {
        throw new InvalidOperationException(
            "AzureAd settings are incomplete. Set TenantId, ClientId, and ClientSecret, or clear them to use managed identity."
        );
    }

    return new ClientSecretCredential(tenantId, clientId, clientSecret);
}

/// <summary>
/// Create a Graph client configured for the selected API version.
/// </summary>
GraphServiceClient CreateGraphClient()
{
    var credential = CreateCredential();
    var graph = new GraphServiceClient(credential, new[] { "https://graph.microsoft.com/.default" });
    graph.RequestAdapter.BaseUrl = SchemaConstants.GraphBaseUrl;
    return graph;
}

ConnectorCore<ItemModel> BuildConnectorCore(GraphServiceClient? graph, TokenCredential? credential, string connectionId)
{
    return new ConnectorCore<ItemModel>(
        graph,
        credential,
        new ItemPayloadAdapter(),
        connectionId,
        ConnectionName(),
        ConnectionDescription(),
        SchemaConstants.ContentCategory,
        <%- isPeopleConnector ? "ProfileSourceWebUrl()" : "null" %>,
        <%- isPeopleConnector ? "ProfileSourceDisplayName()" : "null" %>,
        <%- isPeopleConnector ? "ProfileSourcePriority()" : "null" %>
    );
}

/// <summary>
/// Provision the connection and schema (then profile source for people connectors).
/// </summary>
async Task ProvisionAsync()
{
    var graph = CreateGraphClient();
    var credential = CreateCredential();
    var connectionId = ConnectionId();
    var core = BuildConnectorCore(graph, credential, connectionId);

    await core.ProvisionAsync();
    Console.WriteLine("ok: connection + schema provisioned");
<% if (isPeopleConnector) { -%>
    await core.ProvisionProfileSourceAsync();
    Console.WriteLine("ok: profile source registered");
<% } -%>
    Console.WriteLine("ok: provisioned");
}

/// <summary>
/// Ingest items from the configured input.
/// </summary>
async Task IngestAsync(string? inputPath, bool dryRun, int? limit, bool verbose, bool failFast)
{
    GraphServiceClient? graph = null;
    TokenCredential? credential = null;
    string connectionId = "dry-run";
    if (!dryRun)
    {
        graph = CreateGraphClient();
        credential = CreateCredential();
        connectionId = ConnectionId();
    }

    var path = InputPath(inputPath);

    // Swap this for any IItemSource implementation (API, DB, queue, etc.).
    IItemSource<ItemModel> source = new <%= inputFormat === "json" ? "JsonItemSource" : inputFormat === "yaml" ? "YamlItemSource" : inputFormat === "custom" ? "CustomItemSource" : "CsvItemSource" %>(path);
    var core = BuildConnectorCore(graph, credential, connectionId);

    await core.IngestAsync(source, dryRun, limit, verbose, failFast);
}

/// <summary>
/// Delete the external connection.
/// </summary>
async Task DeleteConnectionAsync()
{
    var graph = CreateGraphClient();
    var credential = CreateCredential();
    var connectionId = ConnectionId();
    var core = BuildConnectorCore(graph, credential, connectionId);

    await core.DeleteConnectionAsync();
    Console.WriteLine("ok: deleted");
}

var inputOption = new Option<string?>("--input") { Description = "Input file path" };
var dryRunOption = new Option<bool>("--dry-run") { Description = "Build payloads but do not send to Graph" };
var failFastOption = new Option<bool>("--fail-fast") { Description = "Abort on the first item failure" };
var limitOption = new Option<int?>("--limit") { Description = "Limit number of items" };
var verboseOption = new Option<bool>("--verbose") { Description = "Print payloads sent to Graph" };

var root = new RootCommand("Connector CLI generated by cocogen");

var provisionCommand = new Command("provision", "Create or update the connection and schema");
provisionCommand.SetAction(async (parseResult, cancellationToken) => await ProvisionAsync());

var ingestCommand = new Command("ingest", "Ingest items from the configured input");
ingestCommand.Options.Add(inputOption);
ingestCommand.Options.Add(dryRunOption);
ingestCommand.Options.Add(failFastOption);
ingestCommand.Options.Add(limitOption);
ingestCommand.Options.Add(verboseOption);
ingestCommand.SetAction(async (parseResult, cancellationToken) =>
{
    var input = parseResult.GetValue(inputOption);
    var dryRun = parseResult.GetValue(dryRunOption);
    var failFast = parseResult.GetValue(failFastOption);
    var limit = parseResult.GetValue(limitOption);
    var verbose = parseResult.GetValue(verboseOption);
    await IngestAsync(input, dryRun, limit, verbose, failFast);
});

var deleteCommand = new Command("delete", "Delete the connection");
deleteCommand.SetAction(async (parseResult, cancellationToken) => await DeleteConnectionAsync());

root.Subcommands.Add(provisionCommand);
root.Subcommands.Add(ingestCommand);
root.Subcommands.Add(deleteCommand);

<% if (isPeopleConnector) { -%>
var registerCommand = new Command("register-profile-source", "Register the connection as a profile source");
registerCommand.SetAction(async (parseResult, cancellationToken) =>
{
    var graph = CreateGraphClient();
    var credential = CreateCredential();
    var connectionId = ConnectionId();
    var core = BuildConnectorCore(graph, credential, connectionId);
    await core.ProvisionProfileSourceAsync();
});
root.Subcommands.Add(registerCommand);
<% } -%>

try
{
    var parseResult = root.Parse(args);
    return await parseResult.InvokeAsync();
}
catch (Exception ex)
{
    Console.Error.WriteLine("error: " + ex.Message);
    return 1;
}
