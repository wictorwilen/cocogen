// Row value parsing helpers used by generated transforms.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Nodes;
<% if (inputFormat !== "csv") { -%>
using Json.Path;
<% } -%>

namespace <%= namespaceName %>.Datasource;

/// <summary>
/// Helpers for parsing typed values from row dictionaries.
/// </summary>
public static class RowParser
{
    /// <summary>
    /// Read the first matching header value from the row.
    /// </summary>
    public static object? ReadValue(object row, string[] headers)
    {
        if (headers.Length == 0) return "";
        if (row is IReadOnlyDictionary<string, object?> dict && dict.TryGetValue(headers[0], out var value))
        {
            return value ?? "";
        }
        return "";
    }

    /// <summary>
    /// Read a value from the row using a JSONPath expression.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static object? ReadValue(object row, string jsonPath)
    {
        if (string.IsNullOrWhiteSpace(jsonPath)) return "";
        if (row is JsonNode node)
        {
            return EvaluateJsonPath(node, jsonPath);
        }
        if (row is JsonElement element)
        {
            var parsed = JsonNode.Parse(element.GetRawText());
            return parsed is null ? "" : EvaluateJsonPath(parsed, jsonPath);
        }
        if (row is IReadOnlyDictionary<string, object?> dict)
        {
            var parsed = JsonNode.Parse(JsonSerializer.Serialize(dict));
            return parsed is null ? "" : EvaluateJsonPath(parsed, jsonPath);
        }
        return "";
    }

    /// <summary>
    /// Read array entries from the row using a JSONPath expression.
    /// </summary>
    public static IEnumerable<object> ReadArrayEntries(object row, string jsonPath)
    {
        var value = ReadValue(row, jsonPath);
        if (value is JsonArray array)
        {
            foreach (var entry in array)
            {
                if (entry is not null) yield return entry;
            }
            yield break;
        }
        if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
        {
            foreach (var entry in element.EnumerateArray())
            {
                yield return entry;
            }
            yield break;
        }

        var trimmed = jsonPath.Trim();
        if (trimmed.EndsWith("[*]", StringComparison.Ordinal))
        {
            var parentPath = trimmed[..^3];
            var parentValue = ReadValue(row, parentPath);
            if (parentValue is JsonArray parentArray)
            {
                foreach (var entry in parentArray)
                {
                    if (entry is not null) yield return entry;
                }
                yield break;
            }
            if (parentValue is JsonElement parentElement && parentElement.ValueKind == JsonValueKind.Array)
            {
                foreach (var entry in parentElement.EnumerateArray())
                {
                    yield return entry;
                }
            }
        }
    }
<% } -%>

    /// <summary>
    /// Parse a nullable string value into a string.
    /// </summary>
    public static string ParseString(object? value)
    {
        if (value is null) return "";
        if (value is JsonNode jsonNode && jsonNode is not JsonValue)
        {
            return jsonNode.ToJsonString();
        }
        if (value is JsonValue jsonValue)
        {
            if (jsonValue.TryGetValue<string>(out var s)) return s ?? "";
            if (jsonValue.TryGetValue<long>(out var l)) return l.ToString(CultureInfo.InvariantCulture);
            if (jsonValue.TryGetValue<double>(out var d)) return d.ToString(CultureInfo.InvariantCulture);
            if (jsonValue.TryGetValue<bool>(out var b)) return b ? "true" : "false";
        }
        if (value is JsonElement element)
        {
            return element.ValueKind switch
            {
                JsonValueKind.String => element.GetString() ?? "",
                JsonValueKind.Number => element.GetRawText(),
                JsonValueKind.True => "true",
                JsonValueKind.False => "false",
                JsonValueKind.Null => "",
                _ => element.GetRawText(),
            };
        }
        return value.ToString() ?? "";
    }

    /// <summary>
    /// Parse a string from a row using the provided headers.
    /// </summary>
    public static string ParseString(object row, string[] headers)
    {
        return ParseString(ReadValue(row, headers));
    }

    /// <summary>
    /// Parse a string from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static string ParseString(object row, string jsonPath)
    {
        return ParseString(ReadValue(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a boolean from a row using the provided headers.
    /// </summary>
    public static bool ParseBoolean(object row, string[] headers)
    {
        return ParseBoolean(ParseString(row, headers));
    }

    /// <summary>
    /// Parse a boolean from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static bool ParseBoolean(object row, string jsonPath)
    {
        return ParseBoolean(ParseString(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a boolean from a string value.
    /// </summary>
    public static bool ParseBoolean(string? value)
    {
        var v = ParseString(value);
        return v.Equals("true", StringComparison.OrdinalIgnoreCase) || v.Equals("1");
    }

    /// <summary>
    /// Parse an Int64 from a row using the provided headers.
    /// </summary>
    public static long ParseInt64(object row, string[] headers)
    {
        return ParseInt64(ParseString(row, headers));
    }

    /// <summary>
    /// Parse an Int64 from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static long ParseInt64(object row, string jsonPath)
    {
        return ParseInt64(ParseString(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse an Int64 from a string value.
    /// </summary>
    public static long ParseInt64(string? value)
    {
        var v = ParseString(value);
        return long.TryParse(v, out var n) ? n : 0;
    }

    /// <summary>
    /// Parse a double from a row using the provided headers.
    /// </summary>
    public static double ParseDouble(object row, string[] headers)
    {
        return ParseDouble(ParseString(row, headers));
    }

    /// <summary>
    /// Parse a double from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static double ParseDouble(object row, string jsonPath)
    {
        return ParseDouble(ParseString(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a double from a string value.
    /// </summary>
    public static double ParseDouble(string? value)
    {
        var v = ParseString(value);
        return double.TryParse(v, out var n) ? n : 0;
    }

    /// <summary>
    /// Parse a DateTimeOffset from a row using the provided headers.
    /// </summary>
    public static DateTimeOffset ParseDateTime(object row, string[] headers)
    {
        return ParseDateTime(ParseString(row, headers));
    }

    /// <summary>
    /// Parse a DateTimeOffset from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static DateTimeOffset ParseDateTime(object row, string jsonPath)
    {
        return ParseDateTime(ParseString(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a DateTimeOffset from a string value.
    /// </summary>
    public static DateTimeOffset ParseDateTime(string? value)
    {
        var v = ParseString(value);
        return DateTimeOffset.TryParse(v, out var dt) ? dt : DateTimeOffset.MinValue;
    }

    /// <summary>
    /// Parse a string collection from a row using the provided headers.
    /// </summary>
    public static List<string> ParseStringCollection(object row, string[] headers)
    {
        return ParseStringCollection(ParseString(row, headers));
    }

    /// <summary>
    /// Parse a string collection from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static List<string> ParseStringCollection(object row, string jsonPath)
    {
        return ParseStringCollection(ReadValue(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a string collection from a string value.
    /// </summary>
    public static List<string> ParseStringCollection(object? value)
    {
        if (value is JsonArray array)
        {
            return array.Select((entry) => ParseString(entry)).Where((entry) => entry.Length > 0).ToList();
        }
        if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
        {
            return element.EnumerateArray().Select((entry) => ParseString(entry)).Where((entry) => entry.Length > 0).ToList();
        }
        var v = ParseString(value);
        if (v.Length == 0) return new List<string>();
    <% if (inputFormat === "csv") { -%>
        return v.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries).ToList();
    <% } else { -%>
        return new List<string> { v };
    <% } -%>
    }

    /// <summary>
    /// Parse an Int64 collection from a row using the provided headers.
    /// </summary>
    public static List<long> ParseInt64Collection(object row, string[] headers)
    {
        return ParseInt64Collection(ParseString(row, headers));
    }

    /// <summary>
    /// Parse an Int64 collection from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static List<long> ParseInt64Collection(object row, string jsonPath)
    {
        return ParseInt64Collection(ReadValue(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse an Int64 collection from a string value.
    /// </summary>
    public static List<long> ParseInt64Collection(object? value)
    {
        if (value is JsonArray array)
        {
            return array.Select((entry) => long.TryParse(ParseString(entry), out var n) ? n : 0).ToList();
        }
        if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
        {
            return element.EnumerateArray().Select((entry) => long.TryParse(ParseString(entry), out var n) ? n : 0).ToList();
        }
        var v = ParseString(value);
        if (v.Length == 0) return new List<long>();
    <% if (inputFormat === "csv") { -%>
        return v.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
            .Select((x) => long.TryParse(x, out var n) ? n : 0)
            .ToList();
    <% } else { -%>
        return long.TryParse(v, out var n) ? new List<long> { n } : new List<long>();
    <% } -%>
    }

    /// <summary>
    /// Parse a double collection from a row using the provided headers.
    /// </summary>
    public static List<double> ParseDoubleCollection(object row, string[] headers)
    {
        return ParseDoubleCollection(ParseString(row, headers));
    }

    /// <summary>
    /// Parse a double collection from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static List<double> ParseDoubleCollection(object row, string jsonPath)
    {
        return ParseDoubleCollection(ReadValue(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a double collection from a string value.
    /// </summary>
    public static List<double> ParseDoubleCollection(object? value)
    {
        if (value is JsonArray array)
        {
            return array.Select((entry) => double.TryParse(ParseString(entry), out var n) ? n : 0).ToList();
        }
        if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
        {
            return element.EnumerateArray().Select((entry) => double.TryParse(ParseString(entry), out var n) ? n : 0).ToList();
        }
        var v = ParseString(value);
        if (v.Length == 0) return new List<double>();
    <% if (inputFormat === "csv") { -%>
        return v.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
            .Select((x) => double.TryParse(x, out var n) ? n : 0)
            .ToList();
    <% } else { -%>
        return double.TryParse(v, out var n) ? new List<double> { n } : new List<double>();
    <% } -%>
    }

    /// <summary>
    /// Parse a DateTimeOffset collection from a row using the provided headers.
    /// </summary>
    public static List<DateTimeOffset> ParseDateTimeCollection(object row, string[] headers)
    {
        return ParseDateTimeCollection(ParseString(row, headers));
    }

    /// <summary>
    /// Parse a DateTimeOffset collection from a row using JSONPath.
    /// </summary>
<% if (inputFormat !== "csv") { -%>
    public static List<DateTimeOffset> ParseDateTimeCollection(object row, string jsonPath)
    {
        return ParseDateTimeCollection(ReadValue(row, jsonPath));
    }
<% } -%>

    /// <summary>
    /// Parse a DateTimeOffset collection from a string value.
    /// </summary>
    public static List<DateTimeOffset> ParseDateTimeCollection(object? value)
    {
        if (value is JsonArray array)
        {
            return array.Select((entry) => DateTimeOffset.TryParse(ParseString(entry), out var dt) ? dt : DateTimeOffset.MinValue).ToList();
        }
        if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
        {
            return element.EnumerateArray().Select((entry) => DateTimeOffset.TryParse(ParseString(entry), out var dt) ? dt : DateTimeOffset.MinValue).ToList();
        }
        var v = ParseString(value);
        if (v.Length == 0) return new List<DateTimeOffset>();
    <% if (inputFormat === "csv") { -%>
        return v.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
            .Select((x) => DateTimeOffset.TryParse(x, out var dt) ? dt : DateTimeOffset.MinValue)
            .ToList();
    <% } else { -%>
        return DateTimeOffset.TryParse(v, out var dt) ? new List<DateTimeOffset> { dt } : new List<DateTimeOffset>();
    <% } -%>
    }

<% if (inputFormat !== "csv") { -%>
    private static object? EvaluateJsonPath(JsonNode node, string jsonPath)
    {
        try
        {
            var normalized = NormalizeJsonPath(jsonPath);
            if (string.IsNullOrWhiteSpace(normalized)) return "";
            if (!TryParseJsonPath(normalized, out var path, out var canonical)) return "";

            var result = path.Evaluate(node);
            var matches = result.Matches?.ToList() ?? new List<Node>();
            if (matches.Count == 0) return "";
            if (matches.Count == 1) return matches[0]?.Value;
            var array = new JsonArray();
            foreach (var match in matches)
            {
                if (match?.Value is null)
                {
                    array.Add(JsonValue.Create(string.Empty)!);
                    continue;
                }
                if (match.Value is JsonValue jsonValue && jsonValue.TryGetValue<JsonElement>(out var elementValue))
                {
                    var parsed = JsonNode.Parse(elementValue.GetRawText());
                    array.Add(CoalesceNode(parsed ?? JsonValue.Create(elementValue.GetRawText()) ?? JsonValue.Create(string.Empty)));
                    continue;
                }
                if (match.Value is JsonValue jsonScalar)
                {
                    array.Add(CoalesceNode(jsonScalar));
                    continue;
                }
                if (match.Value is JsonNode nodeValue)
                {
                    array.Add(CoalesceNode(nodeValue));
                    continue;
                }
                array.Add(CoalesceNode(JsonValue.Create(match.Value) ?? JsonValue.Create(string.Empty)));
            }
            return array;
        }
        catch
        {
            return "";
        }
    }

    private static JsonNode CoalesceNode(JsonNode? node)
    {
        return node ?? JsonValue.Create(string.Empty)!;
    }

    private static string NormalizeJsonPath(string jsonPath)
    {
        var trimmed = jsonPath.Trim();
        if (trimmed.Length == 0) return "";
        if (trimmed.StartsWith("$")) return trimmed;
        if (trimmed.StartsWith("[")) return "$" + trimmed;
        return "$." + trimmed;
    }

    private static bool TryParseJsonPath(string jsonPath, out JsonPath path, out string canonical)
    {
        canonical = "";
        if (JsonPath.TryParse(jsonPath, out path)) return true;

        if (!TryBuildCanonicalJsonPath(jsonPath, out canonical))
        {
            return false;
        }

        return JsonPath.TryParse(canonical, out path);
    }


    private enum JsonPathStepKind
    {
        Property,
        Index,
        Wildcard
    }

    private sealed record JsonPathStep(JsonPathStepKind Kind, string Value, int Index);

    private static bool TryBuildCanonicalJsonPath(string jsonPath, out string canonical)
    {
        canonical = "";
        var trimmed = jsonPath.Trim();
        if (trimmed.Length == 0) return false;
        if (trimmed.Contains("..", StringComparison.Ordinal) ||
            trimmed.Contains("?", StringComparison.Ordinal) ||
            trimmed.Contains("@", StringComparison.Ordinal) ||
            trimmed.Contains(":", StringComparison.Ordinal))
        {
            return false;
        }

        var steps = ParseJsonPathSteps(trimmed);
        if (steps.Count == 0) return false;

        var parts = new List<string> { "$" };
        foreach (var step in steps)
        {
            switch (step.Kind)
            {
                case JsonPathStepKind.Property:
                    parts.Add("[\"" + step.Value
                        .Replace("\\", "\\\\", StringComparison.Ordinal)
                        .Replace("\"", "\\\"", StringComparison.Ordinal) + "\"]");
                    break;
                case JsonPathStepKind.Index:
                    parts.Add("[" + step.Index.ToString(CultureInfo.InvariantCulture) + "]");
                    break;
                case JsonPathStepKind.Wildcard:
                    parts.Add("[*]");
                    break;
            }
        }

        canonical = string.Concat(parts);
        return true;
    }

    private static List<JsonPathStep> ParseJsonPathSteps(string jsonPath)
    {
        var trimmed = jsonPath.Trim();
        if (trimmed.StartsWith("$")) trimmed = trimmed[1..];
        if (trimmed.StartsWith(".")) trimmed = trimmed[1..];

        var steps = new List<JsonPathStep>();
        foreach (var segment in trimmed.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
        {
            if (segment.Length == 0) continue;
            var remaining = segment;
            var bracketIndex = remaining.IndexOf('[');
            var prop = bracketIndex >= 0 ? remaining[..bracketIndex] : remaining;
            if (prop.Length > 0)
            {
                steps.Add(new JsonPathStep(JsonPathStepKind.Property, prop, -1));
            }

            while (bracketIndex >= 0)
            {
                var end = remaining.IndexOf(']', bracketIndex + 1);
                if (end <= bracketIndex) break;
                var content = remaining[(bracketIndex + 1)..end].Trim();
                if (content.Length >= 2 &&
                    ((content.StartsWith("\"") && content.EndsWith("\"")) ||
                     (content.StartsWith("'") && content.EndsWith("'"))))
                {
                    var unquoted = content[1..^1];
                    if (unquoted == "*")
                    {
                        steps.Add(new JsonPathStep(JsonPathStepKind.Wildcard, "", -1));
                    }
                    else
                    {
                        steps.Add(new JsonPathStep(JsonPathStepKind.Property, unquoted, -1));
                    }
                }
                else if (content == "*")
                {
                    steps.Add(new JsonPathStep(JsonPathStepKind.Wildcard, "", -1));
                }
                else if (int.TryParse(content, out var index))
                {
                    steps.Add(new JsonPathStep(JsonPathStepKind.Index, "", index));
                }
                bracketIndex = remaining.IndexOf('[', end + 1);
            }
        }
        return steps;
    }
<% } -%>
}