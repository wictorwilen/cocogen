// Generated property transforms derived from TypeSpec.
using System;
using System.Collections.Generic;
<% if (usesPersonEntity) { -%>
using System.Linq;
using System.Text.Json;
<% } -%>
using <%= namespaceName %>.Core;
using <%= namespaceName %>.Datasource;

namespace <%= schemaNamespace %>;

/// <summary>
/// Base class for row-to-model property transforms.
/// </summary>
public abstract class PropertyTransformBase
{
    /// <summary>
    /// Transform a property by name using the generated transform methods.
    /// </summary>
    public object TransformProperty(string name, IReadOnlyDictionary<string, string?> row)
    {
        return name switch
        {
<% for (const prop of properties) { -%>
            <%= JSON.stringify(prop.name) %> => Transform<%= prop.csName %>(row),
<% } -%>
            _ => throw new ArgumentOutOfRangeException(nameof(name), $"Unknown property '{name}'."),
        };
    }

<% for (const prop of properties) { -%>
    /// <summary>
    /// Transform the <%= prop.name %> property from a source row.
    /// </summary>
    protected virtual <%= prop.csType %> Transform<%= prop.csName %>(IReadOnlyDictionary<string, string?> row)
    {
    <% if (prop.transformThrows) { -%>
        <%- prop.transformExpression %>;
    <% } else { -%>
        return <%- prop.transformExpression %>;
    <% } -%>
    }

<% } -%>

    private static List<DateTimeOffset> ValidateDateTimeCollection(string name, string raw, int? minLength, int? maxLength, string? pattern, string? format)
    {
        var parts = RowParser.ParseStringCollection(raw);
        if (parts.Count == 0) return new List<DateTimeOffset>();
        var results = new List<DateTimeOffset>(parts.Count);
        for (var index = 0; index < parts.Count; index++)
        {
            var validated = Validation.ValidateString(name, parts[index], minLength, maxLength, pattern, format);
            results.Add(RowParser.ParseDateTime(validated));
        }
        return results;
    }
}
