Generated by cocogen.

## Quickstart
1) Edit `appsettings.json` with your tenant/app/connection details.
2) `dotnet build`
3) `dotnet run -- provision`
<% if (inputFormat === "custom") { -%>
4) Implement your datasource in `Datasource/CustomItemSource.cs`
5) `dotnet run -- ingest --input <your-source>`
6) (Optional) `dotnet run -- delete`
<% } else { -%>
4) `dotnet run -- ingest --input ./data.<%= inputFormat === "json" ? "json" : inputFormat === "yaml" ? "yaml" : "csv" %>`
5) (Optional) `dotnet run -- delete`
<% } -%>

<% if (isPeopleConnector) { -%>
Note: this is a People connector (preview). It uses Graph beta endpoints and registers the connection as a profile source during `provision`.
<% } -%>

## Graph API version note
If your schema sets `@coco.connection({ contentCategory: "..." })`, provisioning must use Microsoft Graph **/beta** because `externalConnection.contentCategory` is currently exposed on the beta endpoint.

## Multiple connections
This generated CLI currently targets a single connection ID from configuration. Multi-connection support is planned for a future version.

## Requirements
- .NET 10 SDK
- Microsoft Entra app registration with application permissions:
  - `ExternalConnection.ReadWrite.OwnedBy`
  - `ExternalItem.ReadWrite.OwnedBy`
<% if (isPeopleConnector) { -%>
  - `PeopleSettings.ReadWrite.All` (required for profile source registration)
<% } -%>

## Authentication
The generated CLI uses the following order:
1) Client secret (`AzureAd:TenantId` + `AzureAd:ClientId` + `AzureAd:ClientSecret`)
2) Managed identity (when no client secret is configured)

To use client secret auth locally, set `AzureAd:TenantId`, `AzureAd:ClientId`, and `AzureAd:ClientSecret` in `appsettings.json`, environment variables, or user-secrets.

User-secrets are supported:
```bash
dotnet user-secrets set "AzureAd:TenantId" "<tenant-id>"
dotnet user-secrets set "AzureAd:ClientId" "<client-id>"
dotnet user-secrets set "AzureAd:ClientSecret" "<client-secret>"
```

## TypeSpec editor support
This project includes `tspconfig.yaml` and a `package.json` with `@wictorwilen/cocogen` as a dev dependency so VS Code can resolve `using coco;`.
Run `npm install` in this folder to fetch the TypeSpec library.

## Customizing the project
- **Schema and fields**: edit `schema.tsp` (copied into this folder) and run `cocogen update --out .` to regenerate `<%= schemaFolderName %>/`.
- **Ingestion**: replace the datasource in `Datasource/` (generated for <%= inputFormat %>) and wire it in `Program.cs`.
<% if (inputFormat === "custom") { -%>
- **Custom input**: `CustomItemSource` throws by defaultâ€”replace it with your own backend implementation.
<% } -%>
- **Input format**: fixed to `<%= inputFormat %>` for this project. Re-run `cocogen generate` to switch formats.
- **Property transforms**: edit `<%= schemaFolderName %>/PropertyTransform.cs` (kept on updates) to customize per-field parsing/mapping.
- **Connection defaults**: `@coco.connection` must set `name`, `connectionId`, and `connectionDescription` defaults for `appsettings.json`.
- **Profile source defaults**: `@coco.profileSource` sets defaults for `ProfileSource` settings (people connectors only).
- **Access control**: edit `<%= schemaFolderName %>/ItemPayload.cs` to change ACL behavior.

## Ingest debugging flags
Use `dotnet run -- ingest` with:
- `--dry-run` (build payloads without sending)
- `--fail-fast` (abort on the first item failure)
- `--limit <n>` (ingest only N items)
- `--verbose` (print the exact payload sent to Graph)

Note: `--dry-run` does not require Azure AD or connection settings.

## Switching from the generated datasource
1) Implement `IItemSource<<%= itemTypeName %>>` in `Datasource/`.
2) If your source yields raw records, map them to `<%= itemTypeName %>` using `FromRow`-style logic.
3) Update `Program.cs` to instantiate your new source instead of the generated source.

Tip: keep the `IAsyncEnumerable<<%= itemTypeName %>>` pattern for large datasets.

