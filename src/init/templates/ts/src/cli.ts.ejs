/**
 * Connector CLI for provisioning, ingestion, and deletion.
 */
import "dotenv/config";

import { Command } from "commander";
import { ClientSecretCredential, ManagedIdentityCredential } from "@azure/identity";

import type { <%= itemTypeName %> } from "./<%= schemaFolderName %>/model.js";
import {
  contentCategory,
  connectionName as defaultConnectionName,
  connectionId as defaultConnectionId,
  connectionDescription as defaultConnectionDescription,
  profileSourceWebUrl as defaultProfileSourceWebUrl,
  profileSourceDisplayName as defaultProfileSourceDisplayName,
  profileSourcePriority as defaultProfileSourcePriority,
  schemaPayload
} from "./<%= schemaFolderName %>/index.js";
import { getItemId, toExternalItem } from "./<%= schemaFolderName %>/itemPayload.js";
import type { ItemSource } from "./datasource/itemSource.js";
<% if (inputFormat === "json") { -%>
import { JsonItemSource } from "./datasource/jsonItemSource.js";
<% } else if (inputFormat === "yaml") { -%>
import { YamlItemSource } from "./datasource/yamlItemSource.js";
<% } else if (inputFormat === "rest") { -%>
import { RestItemSource, type RestItemSourceOptions } from "./datasource/restItemSource.js";
<% } else if (inputFormat === "custom") { -%>
import { CustomItemSource } from "./datasource/customItemSource.js";
<% } else { -%>
import { CsvItemSource } from "./datasource/csvItemSource.js";
<% } -%>
import { ConnectorCore } from "./core/connectorCore.js";

const GRAPH_BASE_URL = <%= JSON.stringify(graphBaseUrl) %>;
const GRAPH_SCOPE = "https://graph.microsoft.com/.default";

const useColor = !process.env.NO_COLOR;
const color = {
  cyan: (value: string) => (useColor ? `\u001b[36m${value}\u001b[0m` : value),
  green: (value: string) => (useColor ? `\u001b[32m${value}\u001b[0m` : value),
  yellow: (value: string) => (useColor ? `\u001b[33m${value}\u001b[0m` : value),
  dim: (value: string) => (useColor ? `\u001b[2m${value}\u001b[0m` : value),
};

function printBanner(): void {
  const title = color.cyan(`âœ¨ ðŸ¥¥ <%= itemTypeName %> connector CLI ðŸ¥¥ âœ¨`);
  const subtitle = color.dim("Provision â€¢ Ingest â€¢ Delete");
  console.log(`${title}\n${subtitle}`);
}

printBanner();

/**
 * Resolve a required environment variable or throw a friendly error.
 */
function requiredEnv(name: string): string {
  const value = process.env[name];
  if (!value) throw new Error(`Missing env var: ${name}`);
  return value;
}

/**
 * Resolve the connection ID from env or schema defaults.
 */
function resolveConnectionId(): string {
  const value = process.env.CONNECTION_ID ?? defaultConnectionId;
  if (!value) throw new Error("Missing env var: CONNECTION_ID");
  return value;
}

function resolveConnectionName(): string {
  const value = process.env.CONNECTION_NAME ?? defaultConnectionName;
  if (!value) throw new Error("Missing env var: CONNECTION_NAME");
  return value;
}

function resolveConnectionDescription(): string {
  const value = process.env.CONNECTION_DESCRIPTION ?? defaultConnectionDescription;
  return value ?? "";
}

function resolveProfileSourceWebUrl(): string {
  const value = process.env.PROFILE_SOURCE_WEB_URL ?? defaultProfileSourceWebUrl;
  if (!value) throw new Error("Missing env var: PROFILE_SOURCE_WEB_URL");
  return value;
}

function resolveProfileSourcePriority(): "first" | "last" {
  const raw = process.env.PROFILE_SOURCE_PRIORITY ?? defaultProfileSourcePriority ?? "first";
  const value = raw.trim().toLowerCase();
  if (value !== "first" && value !== "last") {
    throw new Error("Invalid PROFILE_SOURCE_PRIORITY: expected 'first' or 'last'");
  }
  return value as "first" | "last";
}

function resolveInputPath(inputPath?: string): string {
  if (inputPath) return inputPath;
  return <%= JSON.stringify(
    inputFormat === "custom"
      ? ""
      : inputFormat === "json"
      ? "data.json"
      : inputFormat === "yaml"
      ? "data.yaml"
      : inputFormat === "rest"
      ? ""
      : "data.csv"
  ) %>;
}

function buildItemSource(path: string): ItemSource<<%= itemTypeName %>> {
<% if (inputFormat === "rest") { -%>
  return new RestItemSource(resolveRestOptions(path));
<% } else { -%>
  return new <%= inputFormat === "json" ? "JsonItemSource" : inputFormat === "yaml" ? "YamlItemSource" : inputFormat === "custom" ? "CustomItemSource" : "CsvItemSource" %>(path);
<% } -%>
}

<% if (inputFormat === "rest") { -%>
function resolveRestOptions(inputPath?: string): RestItemSourceOptions {
  const baseUrl = inputPath || process.env.REST_BASE_URL || "";
  if (!baseUrl) throw new Error("Missing REST_BASE_URL or --input for REST ingestion.");
  return { baseUrl };
}
<% } -%>

let cachedCredential: ClientSecretCredential | ManagedIdentityCredential | null = null;
let cachedToken: { token: string; expiresOnTimestamp: number } | null = null;

function resolveCredential(): ClientSecretCredential | ManagedIdentityCredential {
  if (cachedCredential) return cachedCredential;

  const tenantId = process.env.TENANT_ID;
  const clientId = process.env.CLIENT_ID;
  const clientSecret = process.env.CLIENT_SECRET;

  if (tenantId && clientId && clientSecret) {
    cachedCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
    return cachedCredential;
  }

  const managedIdentityClientId = process.env.MANAGED_IDENTITY_CLIENT_ID;
  cachedCredential = managedIdentityClientId
    ? new ManagedIdentityCredential(managedIdentityClientId)
    : new ManagedIdentityCredential();
  return cachedCredential;
}

async function getAccessToken(): Promise<string> {
  if (cachedToken && cachedToken.expiresOnTimestamp - Date.now() > 60_000) {
    return cachedToken.token;
  }

  const credential = resolveCredential();
  const token = await credential.getToken(GRAPH_SCOPE);
  if (!token?.token) throw new Error("Failed to acquire access token");
  cachedToken = token;
  return token.token;
}

/**
 * Build a reusable connector core instance.
 */
function buildConnectorCore(): ConnectorCore<<%= itemTypeName %>> {
  const profileSource = <%- isPeopleConnector
    ? `{
    webUrl: resolveProfileSourceWebUrl(),
    displayName: process.env.PROFILE_SOURCE_DISPLAY_NAME ?? defaultProfileSourceDisplayName ?? requiredEnv("CONNECTION_NAME"),
    priority: resolveProfileSourcePriority()
  }`
    : "undefined" %>;

  return new ConnectorCore<<%= itemTypeName %>>({
    graphBaseUrl: GRAPH_BASE_URL,
    contentCategory,
    schemaPayload,
    getAccessToken,
    getItemId,
    toExternalItem,
    profileSource
  });
}

/**
 * Provision connection + schema (and then profile source for people connectors).
 */
async function provision(): Promise<void> {
  const connectionId = resolveConnectionId();
  const core = buildConnectorCore();
  await core.provision({
    connectionId,
    connectionName: resolveConnectionName(),
    connectionDescription: resolveConnectionDescription()
  });
  console.log("ok: connection + schema provisioned");
<% if (isPeopleConnector) { -%>
  await core.provisionProfileSource(connectionId);
  console.log("ok: profile source registered");
<% } -%>
  console.log("ok: provisioned");
}

/**
 * Delete the external connection.
 */
async function deleteConnection(): Promise<void> {
  const connectionId = resolveConnectionId();
  const core = buildConnectorCore();
  await core.deleteConnection(connectionId);
  console.log("ok: deleted");
}

/**
 * Ingest items from the configured datasource.
 */
async function ingest(options: {
  inputPath?: string;
  dryRun?: boolean;
  limit?: number;
  verbose?: boolean;
  failFast?: boolean;
}): Promise<void> {
  const connectionId = options.dryRun ? "dry-run" : resolveConnectionId();
  const path = resolveInputPath(options.inputPath);
  const source = buildItemSource(path);
  const core = buildConnectorCore();
  await core.ingest({
    source,
    connectionId,
    dryRun: options.dryRun,
    limit: options.limit,
    verbose: options.verbose,
    failFast: options.failFast,
    toExternalItem
  });
}

const program = new Command();
program.name("connector").description("Connector CLI generated by cocogen");

program
  .command("provision")
  .description("Create or update the connection and schema")
  .action(() => provision());

program
  .command("ingest")
  .description("Ingest items from the configured input file")
  .option("--input <path>", <%= JSON.stringify(inputFormat === "rest" ? "Input file path or REST base URL" : "Input file path") %>)
  .option("--dry-run", "Build payloads but do not send to Graph")
  .option("--fail-fast", "Abort on the first item failure")
  .option("--limit <n>", "Limit number of items", (value) => Number(value))
  .option("--verbose", "Print payloads sent to Graph")
  .action((options: { input?: string; dryRun?: boolean; limit?: number; verbose?: boolean; failFast?: boolean }) =>
    ingest({
      inputPath: options.input,
      dryRun: options.dryRun,
      failFast: options.failFast,
      limit: options.limit,
      verbose: options.verbose,
    })
  );

<% if (isPeopleConnector) { -%>
program
  .command("register-profile-source")
  .description("Register the connection as a profile source (people connectors)")
  .action(async () => {
    const connectionId = resolveConnectionId();
    const core = buildConnectorCore();
    await core.provisionProfileSource(connectionId);
  });
<% } -%>

program
  .command("delete")
  .description("Delete the connection (and profile source for people connectors)")
  .action(() => deleteConnection());

program.parseAsync(process.argv).catch((e) => {
  console.error("error:", e instanceof Error ? e.message : String(e));
  process.exitCode = 1;
});
