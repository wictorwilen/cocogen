import "dotenv/config";

import { Command } from "commander";
import { ClientSecretCredential } from "@azure/identity";

import type { <%= itemTypeName %> } from "./schema/model.js";
import {
  contentCategory,
  connectionId as defaultConnectionId,
  connectionDescription as defaultConnectionDescription,
  profileSourceWebUrl as defaultProfileSourceWebUrl,
  profileSourceDisplayName as defaultProfileSourceDisplayName,
  profileSourcePriority as defaultProfileSourcePriority,
  schemaPayload
} from "./schema/index.js";
import { getItemId, toExternalItem } from "./schema/itemPayload.js";
import { CsvItemSource } from "./datasource/csvItemSource.js";

const GRAPH_BASE_URL = <%= JSON.stringify(graphBaseUrl) %>;
const PROFILE_SOURCE_URL_PREFIX = `${GRAPH_BASE_URL}/admin/people/profileSources`;

function requiredEnv(name: string): string {
  const value = process.env[name];
  if (!value) throw new Error(`Missing env var: ${name}`);
  return value;
}

function resolveConnectionId(): string {
  const value = process.env.CONNECTION_ID ?? defaultConnectionId;
  if (!value) throw new Error("Missing env var: CONNECTION_ID");
  return value;
}

function resolveConnectionName(): string {
  return requiredEnv("CONNECTION_NAME");
}

function resolveConnectionDescription(): string {
  const value = process.env.CONNECTION_DESCRIPTION ?? defaultConnectionDescription;
  if (!value) throw new Error("Missing env var: CONNECTION_DESCRIPTION");
  return value;
}

function resolveProfileSourceWebUrl(): string {
  const value = process.env.PROFILE_SOURCE_WEB_URL ?? defaultProfileSourceWebUrl;
  if (!value) throw new Error("Missing env var: PROFILE_SOURCE_WEB_URL");
  return value;
}

function resolveProfileSourcePriority(): "first" | "last" {
  const raw = process.env.PROFILE_SOURCE_PRIORITY ?? defaultProfileSourcePriority ?? "first";
  const value = raw.trim().toLowerCase();
  if (value !== "first" && value !== "last") {
    throw new Error("Invalid PROFILE_SOURCE_PRIORITY: expected 'first' or 'last'");
  }
  return value;
}

async function getAccessToken(): Promise<string> {
  const tenantId = requiredEnv("TENANT_ID");
  const clientId = requiredEnv("CLIENT_ID");
  const clientSecret = requiredEnv("CLIENT_SECRET");

  const credential = new ClientSecretCredential(tenantId, clientId, clientSecret);
  const token = await credential.getToken("https://graph.microsoft.com/.default");
  if (!token?.token) throw new Error("Failed to acquire access token");
  return token.token;
}

async function graphRequest(method: string, url: string, body?: unknown): Promise<Response> {
  const token = await getAccessToken();
  return fetch(url, {
    method,
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    },
    body: body ? JSON.stringify(body) : undefined
  });
}

<% if (isPeopleConnector) { -%>
async function listProfilePropertySettings(): Promise<Array<{ id: string; prioritizedSourceUrls: string[] }>> {
  const res = await graphRequest("GET", `${GRAPH_BASE_URL}/admin/people/profilePropertySettings`);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Failed to list profile property settings (HTTP ${res.status}): ${text}`);
  }
  const json = (await res.json()) as { value?: Array<{ id?: string; prioritizedSourceUrls?: string[] }> };
  return (json.value ?? [])
    .filter((entry) => typeof entry.id === "string")
    .map((entry) => ({
      id: entry.id as string,
      prioritizedSourceUrls: Array.isArray(entry.prioritizedSourceUrls) ? entry.prioritizedSourceUrls : [],
    }));
}

async function registerProfileSource(connectionId: string): Promise<void> {
  const webUrl = resolveProfileSourceWebUrl();
  const displayName =
    process.env.PROFILE_SOURCE_DISPLAY_NAME ?? defaultProfileSourceDisplayName ?? requiredEnv("CONNECTION_NAME");
  const priority = resolveProfileSourcePriority();

  const payload: any = {
    sourceId: connectionId,
    displayName,
    webUrl
  };

  const create = await graphRequest("POST", `${GRAPH_BASE_URL}/admin/people/profileSources`, payload);
  if (!create.ok && create.status !== 409) {
    const text = await create.text();
    throw new Error(`Failed to register profile source (HTTP ${create.status}): ${text}`);
  }

  const sourceUrl = `${PROFILE_SOURCE_URL_PREFIX}(sourceId='${connectionId}')`;
  const settings = await listProfilePropertySettings();
  for (const setting of settings) {
    const existing = setting.prioritizedSourceUrls.filter((value) => value !== sourceUrl);
    const updated = priority === "first" ? [sourceUrl, ...existing] : [...existing, sourceUrl];
    const res = await graphRequest(
      "PATCH",
      `${GRAPH_BASE_URL}/admin/people/profilePropertySettings/${setting.id}`,
      {
        "@odata.type": "#microsoft.graph.profilePropertySetting",
        prioritizedSourceUrls: updated
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to update profile property setting ${setting.id} (HTTP ${res.status}): ${text}`);
    }
  }
}

async function unregisterProfileSource(connectionId: string): Promise<void> {
  const sourceUrl = `${PROFILE_SOURCE_URL_PREFIX}(sourceId='${connectionId}')`;
  const settings = await listProfilePropertySettings();
  for (const setting of settings) {
    const updated = setting.prioritizedSourceUrls.filter((value) => value !== sourceUrl);
    const res = await graphRequest(
      "PATCH",
      `${GRAPH_BASE_URL}/admin/people/profilePropertySettings/${setting.id}`,
      {
        "@odata.type": "#microsoft.graph.profilePropertySetting",
        prioritizedSourceUrls: updated
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to update profile property setting ${setting.id} (HTTP ${res.status}): ${text}`);
    }
  }

  const res = await graphRequest(
    "DELETE",
    `${PROFILE_SOURCE_URL_PREFIX}(sourceId='${connectionId}')`
  );
  if (!res.ok && res.status !== 404) {
    const text = await res.text();
    throw new Error(`Failed to delete profile source (HTTP ${res.status}): ${text}`);
  }
}
<% } -%>

async function ensureConnection(connectionId: string): Promise<void> {
  const name = resolveConnectionName();
  const description = resolveConnectionDescription();

  const payload: any = {
    id: connectionId,
    name,
    description
  };

  if (contentCategory) payload.contentCategory = contentCategory;

  const createUrl = `${GRAPH_BASE_URL}/external/connections`;
  const create = await graphRequest("POST", createUrl, payload);
  if (!create.ok) {
    if (create.status !== 409) {
      const text = await create.text();
      throw new Error(`Failed to create connection (HTTP ${create.status}): ${text}`);
    }
  }
}

async function patchSchema(connectionId: string): Promise<void> {
  const schemaUrl = `${GRAPH_BASE_URL}/external/connections/${connectionId}/schema`;
  const res = await graphRequest("PATCH", schemaUrl, schemaPayload);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Failed to patch schema (HTTP ${res.status}): ${text}`);
  }
}

async function provision(): Promise<void> {
  const connectionId = resolveConnectionId();
  await ensureConnection(connectionId);
  await patchSchema(connectionId);
<% if (isPeopleConnector) { -%>
  await registerProfileSource(connectionId);
<% } -%>
  console.log("ok: provisioned");
}

async function deleteConnection(): Promise<void> {
  const connectionId = resolveConnectionId();
<% if (isPeopleConnector) { -%>
  await unregisterProfileSource(connectionId);
<% } -%>
  const res = await graphRequest("DELETE", `${GRAPH_BASE_URL}/external/connections/${connectionId}`);
  if (!res.ok && res.status !== 404) {
    const text = await res.text();
    throw new Error(`Failed to delete connection (HTTP ${res.status}): ${text}`);
  }
  console.log("ok: deleted");
}

async function putItem(connectionId: string, item: <%= itemTypeName %>, verbose: boolean): Promise<void> {
  const itemId = getItemId(item);
  const url = `${GRAPH_BASE_URL}/external/connections/${connectionId}/items/${encodeURIComponent(itemId)}`;

  const payload = toExternalItem(item);
  if (verbose) {
    console.log("verbose: PUT", url);
    console.log("verbose: payload", JSON.stringify(payload, null, 2));
  }

  const res = await graphRequest("PUT", url, payload);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Failed to ingest item '${itemId}' (HTTP ${res.status}): ${text}`);
  }
}

async function ingest(options: {
  csvPath?: string;
  dryRun?: boolean;
  limit?: number;
  verbose?: boolean;
}): Promise<void> {
  const connectionId = options.dryRun ? "dry-run" : resolveConnectionId();
  // Swap this for any ItemSource implementation (API, DB, queue, etc.).
  const source = new CsvItemSource(options.csvPath ?? process.env.CSV_PATH ?? "data.csv");
  let count = 0;
  for await (const item of source.getItems()) {
    if (options.limit && count >= options.limit) break;
    if (!options.dryRun) {
      await putItem(connectionId, item, Boolean(options.verbose));
    } else if (options.verbose) {
      console.log("verbose: DRY RUN item", JSON.stringify(toExternalItem(item), null, 2));
    }
    count++;
  }

  console.log("ok: ingested " + count + " item(s)");
}

const program = new Command();
program.name("connector").description("Connector CLI generated by cocogen");

program
  .command("provision")
  .description("Create or update the connection and schema")
  .action(() => provision());

program
  .command("ingest")
  .description("Ingest items from CSV")
  .option("--csv <path>", "CSV path")
  .option("--dry-run", "Build payloads but do not send to Graph")
  .option("--limit <n>", "Limit number of items", (value) => Number(value))
  .option("--verbose", "Print payloads sent to Graph")
  .action((options: { csv?: string; dryRun?: boolean; limit?: number; verbose?: boolean }) =>
    ingest({
      csvPath: options.csv,
      dryRun: options.dryRun,
      limit: options.limit,
      verbose: options.verbose,
    })
  );

<% if (isPeopleConnector) { -%>
program
  .command("register-profile-source")
  .description("Register the connection as a profile source (people connectors)")
  .action(() => registerProfileSource(resolveConnectionId()));
<% } -%>

program
  .command("delete")
  .description("Delete the connection (and profile source for people connectors)")
  .action(() => deleteConnection());

program.parseAsync(process.argv).catch((e) => {
  console.error("error:", e instanceof Error ? e.message : String(e));
  process.exitCode = 1;
});
