/**
 * Connector CLI for provisioning, ingestion, and deletion.
 */
import "dotenv/config";

import { Command } from "commander";
import { ClientSecretCredential } from "@azure/identity";

import type { <%= itemTypeName %> } from "./schema/model.js";
import {
  contentCategory,
  connectionName as defaultConnectionName,
  connectionId as defaultConnectionId,
  connectionDescription as defaultConnectionDescription,
  profileSourceWebUrl as defaultProfileSourceWebUrl,
  profileSourceDisplayName as defaultProfileSourceDisplayName,
  profileSourcePriority as defaultProfileSourcePriority,
  schemaPayload
} from "./schema/index.js";
import { getItemId, toExternalItem } from "./schema/itemPayload.js";
import { CsvItemSource } from "./datasource/csvItemSource.js";
import { ConnectorCore } from "./core/connectorCore.js";

const GRAPH_BASE_URL = <%= JSON.stringify(graphBaseUrl) %>;

const useColor = !process.env.NO_COLOR;
const color = {
  cyan: (value: string) => (useColor ? `\u001b[36m${value}\u001b[0m` : value),
  green: (value: string) => (useColor ? `\u001b[32m${value}\u001b[0m` : value),
  yellow: (value: string) => (useColor ? `\u001b[33m${value}\u001b[0m` : value),
  dim: (value: string) => (useColor ? `\u001b[2m${value}\u001b[0m` : value),
};

function printBanner(): void {
  const title = color.cyan(`✨ <%= itemTypeName %> connector CLI ✨`);
  const subtitle = color.dim("Provision • Ingest • Delete");
  console.log(`${title}\n${subtitle}`);
}

printBanner();

/**
 * Resolve a required environment variable or throw a friendly error.
 */
function requiredEnv(name: string): string {
  const value = process.env[name];
  if (!value) throw new Error(`Missing env var: ${name}`);
  return value;
}

/**
 * Resolve the connection ID from env or schema defaults.
 */
function resolveConnectionId(): string {
  const value = process.env.CONNECTION_ID ?? defaultConnectionId;
  if (!value) throw new Error("Missing env var: CONNECTION_ID");
  return value;
}

function resolveConnectionName(): string {
  const value = process.env.CONNECTION_NAME ?? defaultConnectionName;
  if (!value) throw new Error("Missing env var: CONNECTION_NAME");
  return value;
}

function resolveConnectionDescription(): string {
  const value = process.env.CONNECTION_DESCRIPTION ?? defaultConnectionDescription;
  if (!value) throw new Error("Missing env var: CONNECTION_DESCRIPTION");
  return value;
}

function resolveProfileSourceWebUrl(): string {
  const value = process.env.PROFILE_SOURCE_WEB_URL ?? defaultProfileSourceWebUrl;
  if (!value) throw new Error("Missing env var: PROFILE_SOURCE_WEB_URL");
  return value;
}

function resolveProfileSourcePriority(): "first" | "last" {
  const raw = process.env.PROFILE_SOURCE_PRIORITY ?? defaultProfileSourcePriority ?? "first";
  const value = raw.trim().toLowerCase();
  if (value !== "first" && value !== "last") {
    throw new Error("Invalid PROFILE_SOURCE_PRIORITY: expected 'first' or 'last'");
  }
  return value as "first" | "last";
}

async function getAccessToken(): Promise<string> {
  const tenantId = requiredEnv("TENANT_ID");
  const clientId = requiredEnv("CLIENT_ID");
  const clientSecret = requiredEnv("CLIENT_SECRET");

  const credential = new ClientSecretCredential(tenantId, clientId, clientSecret);
  const token = await credential.getToken("https://graph.microsoft.com/.default");
  if (!token?.token) throw new Error("Failed to acquire access token");
  return token.token;
}

/**
 * Build a reusable connector core instance.
 */
function buildConnectorCore(): ConnectorCore<<%= itemTypeName %>> {
  const profileSource = <%- isPeopleConnector
    ? `{
    webUrl: resolveProfileSourceWebUrl(),
    displayName: process.env.PROFILE_SOURCE_DISPLAY_NAME ?? defaultProfileSourceDisplayName ?? requiredEnv("CONNECTION_NAME"),
    priority: resolveProfileSourcePriority()
  }`
    : "undefined" %>;

  return new ConnectorCore<<%= itemTypeName %>>({
    graphBaseUrl: GRAPH_BASE_URL,
    contentCategory,
    schemaPayload,
    getAccessToken,
    getItemId,
    toExternalItem,
    profileSource
  });
}

/**
 * Provision connection + schema and (optionally) profile source.
 */
async function provision(): Promise<void> {
  const connectionId = resolveConnectionId();
  const core = buildConnectorCore();
  await core.provision({
    connectionId,
    connectionName: resolveConnectionName(),
    connectionDescription: resolveConnectionDescription()
  });
  console.log("ok: provisioned");
}

/**
 * Delete the external connection.
 */
async function deleteConnection(): Promise<void> {
  const connectionId = resolveConnectionId();
  const core = buildConnectorCore();
  await core.deleteConnection(connectionId);
  console.log("ok: deleted");
}

/**
 * Ingest items from the configured datasource.
 */
async function ingest(options: {
  csvPath?: string;
  dryRun?: boolean;
  limit?: number;
  verbose?: boolean;
}): Promise<void> {
  const connectionId = options.dryRun ? "dry-run" : resolveConnectionId();
  // Swap this for any ItemSource implementation (API, DB, queue, etc.).
  const source = new CsvItemSource(options.csvPath ?? process.env.CSV_PATH ?? "data.csv");
  const core = buildConnectorCore();
  await core.ingest({
    source,
    connectionId,
    dryRun: options.dryRun,
    limit: options.limit,
    verbose: options.verbose,
    toExternalItem
  });
}

const program = new Command();
program.name("connector").description("Connector CLI generated by cocogen");

program
  .command("provision")
  .description("Create or update the connection and schema")
  .action(() => provision());

program
  .command("ingest")
  .description("Ingest items from CSV")
  .option("--csv <path>", "CSV path")
  .option("--dry-run", "Build payloads but do not send to Graph")
  .option("--limit <n>", "Limit number of items", (value) => Number(value))
  .option("--verbose", "Print payloads sent to Graph")
  .action((options: { csv?: string; dryRun?: boolean; limit?: number; verbose?: boolean }) =>
    ingest({
      csvPath: options.csv,
      dryRun: options.dryRun,
      limit: options.limit,
      verbose: options.verbose,
    })
  );

<% if (isPeopleConnector) { -%>
program
  .command("register-profile-source")
  .description("Register the connection as a profile source (people connectors)")
  .action(async () => {
    const connectionId = resolveConnectionId();
    const core = buildConnectorCore();
    await core.registerProfileSource(connectionId);
  });
<% } -%>

program
  .command("delete")
  .description("Delete the connection (and profile source for people connectors)")
  .action(() => deleteConnection());

program.parseAsync(process.argv).catch((e) => {
  console.error("error:", e instanceof Error ? e.message : String(e));
  process.exitCode = 1;
});
