/**
 * CSV parsing helpers used by generated transforms.
 */
/** Parse any CSV cell value into a string (empty when nullish). */
function parseString(value: unknown): string {
  if (value === undefined || value === null) return "";
  return String(value);
}

/** Parse a numeric CSV cell into a number (defaults to 0). */
function parseNumber(value: unknown): number {
  const text = parseString(value).trim();
  if (!text) return 0;
  const numberValue = Number(text);
  return Number.isFinite(numberValue) ? numberValue : 0;
}

/** Parse a boolean-ish CSV cell into a boolean. */
function parseBoolean(value: unknown): boolean {
  const text = parseString(value).trim().toLowerCase();
  return text === "true" || text === "1" || text === "yes";
}

/** Split a delimited CSV cell into an array of strings. */
function splitCollection(value: unknown): string[] {
  const text = parseString(value).trim();
  if (!text) return [];
  return text.split(/\s*;\s*/).map((s) => s.trim()).filter(Boolean);
}

/** Parse a string collection from a CSV cell. */
function parseStringCollection(value: unknown): string[] {
  return splitCollection(value);
}

/** Parse a number collection from a CSV cell. */
function parseNumberCollection(value: unknown): number[] {
  return splitCollection(value).map((s) => parseNumber(s));
}

/** Read a value from a row using the first matching header. */
function readSourceValue(row: Record<string, unknown>, headers: string[]): unknown {
  if (headers.length === 0) return "";
  return row[headers[0]];
}

export {
  parseString,
  parseNumber,
  parseBoolean,
  parseStringCollection,
  parseNumberCollection,
  readSourceValue
};
