/**
 * Graph people entity helpers (generated).
 */

type UnknownObject = { [key: string]: unknown };

const isRecord = (value: unknown): value is UnknownObject =>
  typeof value === "object" && value !== null && !Array.isArray(value);

const parseJsonValue = (raw: string, fieldPath: string): unknown => {
  try {
    return JSON.parse(raw);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`${fieldPath} must be valid JSON (${message}).`);
  }
};

const normalizeSingleValue = (
  value: unknown,
  fieldName: string
): UnknownObject | undefined => {
  if (value === undefined || value === null) return undefined;
  if (typeof value !== "string") {
    throw new Error(`${fieldName} must be a JSON-encoded string.`);
  }
  const trimmed = value.trim();
  if (!trimmed) {
    throw new Error(`${fieldName} must be a non-empty JSON string.`);
  }
  const parsed = parseJsonValue(trimmed, fieldName);
  if (!isRecord(parsed)) {
    throw new Error(`${fieldName} must be a JSON object.`);
  }
  return parsed;
};

const normalizeCollectionValue = (
  value: unknown,
  fieldName: string
): Array<UnknownObject> | undefined => {
  if (value === undefined || value === null) return undefined;
  if (!Array.isArray(value)) {
    throw new Error(`${fieldName} must be an array of JSON strings.`);
  }

  const results: Array<UnknownObject> = [];
  value.forEach((entry, index) => {
    if (typeof entry !== "string") {
      throw new Error(`${fieldName}[${index}] must be a JSON-encoded string.`);
    }
    const trimmed = entry.trim();
    if (!trimmed) {
      throw new Error(`${fieldName}[${index}] must be a non-empty JSON string.`);
    }
    const parsed = parseJsonValue(trimmed, `${fieldName}[${index}]`);
    if (!isRecord(parsed)) {
      throw new Error(`${fieldName}[${index}] must be a JSON object.`);
    }
    results.push(parsed);
  });

  return results;
};

<% if (graphEnums && graphEnums.length > 0) { -%>
<% for (const enumDef of graphEnums) { -%>
export type <%= enumDef.tsName %> =
<% for (const value of enumDef.values) { -%>
  | <%= JSON.stringify(value) %>
<% } -%>
;

const <%= enumDef.tsName %>Values = new Set([
<% for (const value of enumDef.values) { -%>
  <%= JSON.stringify(value) %>,
<% } -%>
]);

const is<%= enumDef.tsName %> = (value: unknown): value is <%= enumDef.tsName %> =>
  typeof value === "string" && <%= enumDef.tsName %>Values.has(value);

<% } -%>
<% } -%>

<% for (const type of graphTypes) { -%>
export type <%= type.alias %> = <%= type.baseAlias ? `${type.baseAlias} & ` : "" %>{
<% for (const field of type.fields) { -%>
  <%= field.name %><%= field.optional ? "?" : "" %>: <%= field.optional ? `${field.tsType} | null` : field.tsType %>;
<% } -%>
};

export function validate<%= type.alias %>(value: unknown, fieldPath: string): <%= type.alias %> {
<% if (type.baseAlias) { -%>
  validate<%= type.baseAlias %>(value, fieldPath);
<% } -%>
  if (!isRecord(value)) {
    throw new Error(`${fieldPath} must be an object.`);
  }
<% if (type.alias === "ItemFacet") { -%>
  if ((value as UnknownObject)["id"] !== undefined) {
    throw new Error(fieldPath + ".id is read-only and must not be provided.");
  }
  for (const key of ["createdBy", "createdDateTime", "lastModifiedBy", "lastModifiedDateTime", "source", "sources"]) {
    if ((value as UnknownObject)[key] !== undefined) {
      throw new Error(fieldPath + "." + key + " is read-only and must not be provided.");
    }
  }
<% } -%>
<% for (const field of type.fields) { -%>
  const <%= field.varName %> = (value as UnknownObject)[<%= JSON.stringify(field.name) %>];
  if (<%= field.varName %> === undefined || <%= field.varName %> === null) {
<% if (!field.optional) { -%>
    throw new Error(fieldPath + ".<%= field.name %> is required.");
<% } -%>
  } else {
<% if (field.isCollection) { -%>
    if (!Array.isArray(<%= field.varName %>)) {
      throw new Error(fieldPath + ".<%= field.name %> must be an array.");
    }
    (<%= field.varName %> as unknown[]).forEach((entry, entryIndex) => {
      if (!(<%= field.elementTypeCheck %>)) {
        throw new Error(fieldPath + ".<%= field.name %>[" + entryIndex + "] must be <%= field.elementExpected %>.");
      }
    });
<% } else { -%>
    if (!(<%= field.typeCheck %>)) {
      throw new Error(fieldPath + ".<%= field.name %> must be <%= field.expected %>.");
    }
<% } -%>
  }
<% } -%>
  return value as <%= type.alias %>;
}

<% } -%>
<% for (const label of labels) { -%>
export function <%= label.serializerName %>(
  value: unknown,
  fieldName = <%= JSON.stringify(label.label) %>
): <%= label.isCollection ? "string[] | undefined" : "string | undefined" %> {
<% if (label.isCollection) { -%>
  const payloads = normalizeCollectionValue(value, fieldName);
  if (!payloads) return undefined;
  if (payloads.length === 0) return [];
<% if (label.collectionLimit) { -%>
  if (payloads.length > <%= label.collectionLimit %>) {
    throw new Error(
      `${fieldName} supports at most <%= label.collectionLimit %> entries (received ${"${payloads.length}"}).`
    );
  }
<% } -%>
  return payloads.map((payload, index) =>
    JSON.stringify(validate<%= label.graphTypeAlias %>(payload, `${fieldName}[${"${index}"}]`))
  );
<% } else { -%>
  const payload = normalizeSingleValue(value, fieldName);
  if (!payload) return undefined;
  const validated = validate<%= label.graphTypeAlias %>(payload, fieldName);
  return JSON.stringify(validated);
<% } -%>
}

<% } -%>
